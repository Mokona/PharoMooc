! Inheritance Semantics and Method Lookup

- Stephane Ducasse
- stephane.ducasse@univ-savoie.fr
- *>http://www.listic.univ-savoie.fr/~ducasse/*

!! Goal

- Inheritance
- Method lookup
- Self/super difference

+>file://figures/LogoPharo.png+

!! Inheritance
- Do not want to rewrite everything!
- Often we want small changes
- We would like to reuse and extend existing behavior

- Solution: class inheritance

- Each class defines or refines the definition of its ancestors

+>file://figures/InheritanceDiagram.png+

- New classes
--Can add state and behavior:
---color, borderColor, borderWidth,
---totalArea

-Can specialize ancestor behavior
--intersect:

- Can use ancestor's behavior and state
- Can redefine ancestor's behavior
--area to return totalArea

- Single inheritance

- Static for the instance variables
-- At class creation time the instance variables are collected from the superclasses and the class. No repetition of instance variables.

- Dynamic for the methods
-- Late binding (all virtual) methods are looked up at runtime depending on the dynamic type of the receiver.

!! How to Invoke Overridden Methods?

- Solution: Send messages to super
[[[
Workstation>>accept: aPacket
(aPacket isAddressedTo: self)
ifTrue:[Transcript show: 'Accepted by the Workstation ', self
name asString]
ifFalse: [super accept: aPacket]
]]]
- Design Hint: Do not send messages to super with different selectors than the original one. It introduces implicit dependency between methods with different names.

!! The semantics of super
- Like self, super is a pseudo-variable that refers to the receiver of the message.
- super is used to invoke overridden methods.

- Using self, the lookup of the method begins in the class of the receiver.

- Using super, the lookup of the method begins in the superclass of the class of the method containing the super expression

!! super changes lookup starting class

- A new foo

- A new bar

- B new foo

- B new bar

- C new foo

- C new bar

- A new bar

- -> 10

- B new bar

- -> 10 \+ 10

- C new bar

- -> 50 \+ 50

+>file://figures/SuperChangesLookup.png+

!! self is dynamic

+>file://figures/SelfIsDynamic.png+

!! Super is static

+>file://figures/SuperIsStatic.png+

!! super is NOT the superclass of the receiver

- Suppose the WRONG hypothesis: "The semantics of super is to start the lookup of a method in the superclass of the receiver class"
- mac is instance of ColoredWorkStation
- Lookup starts in ColoredWorkStation
- Not found so goes up...

- accept: is defined in Workstation
-- lookup stops
-- method accept: is executed
- Workstation>>accept: does a super send
- Our hypothesis: start in the super of the class of the receiver
- => superclass of class of a ColoredWorkstation
is ... Workstation !
- 

+>file://figures/ExplenationSuper.png+
!! What you should know

- Inheritance of instance variables is made at class definition time.
- Inheritance of behavior is dynamic.
- self **always** represents the receiver, the method lookup starts in the class of the receiver.
- super represents the receiver but method lookup starts in the superclass of the class using it.
- Self is dynamic vs. super is static.
