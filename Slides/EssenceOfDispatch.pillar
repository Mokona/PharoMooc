! To the Roots of Objects: Learning from beauty

- StÃ©phane Ducasse
- stephane.ducasse@inria.fr
- *http://stephane.ducasse.free.fr/>http://stephane.ducasse.free.fr/*

!! Really?!
- No primitive types
- No hardcoded constructs for conditional
- Only messages
- Only objects

- and this works?
- I mean really?
- Not even slow?
- Can't be real!

!! Motto
- Let's open our eyes, look, understand, and deeply understand the underlying design aspects of object-oriented programming.

!! Booleans
[[[language=smalltalk 
3 > 0
	ifTrue: ['positive']
	ifFalse: ['negative']
-> 'positive'
]]]

!! Yes ifTrue:ifFalse: is a message!

[[[language=smalltalk 
Weather isRaining
	ifTrue: [self takeMyUmbrella]
	ifFalse: [self takeMySunglasses]
]]]

- Conceptually ==ifTrue:ifFalse:== is a message sent to an object: a boolean!
- ==ifTrue:ifFalse:== is in fact radically optimized by the compiler but you can implement another one such ==siAlors:sinon:== and check. 


!! Booleans
In Pharo booleans have nothing special
- & | not
- or: and: (lazy)
- xor:
- ifTrue:ifFalse:
- ifFalse:ifTrue:
- ...

!! Lazy Logical Operators

[[[language=smalltalk 
	false and: [1 error: 'crazy']
 -> false and not an error
]]]



!! Exercise 1: Implement not
- Propose an implementation of not in a world where you do not have Booleans.
- You only have objects and messages.
[[[language=smalltalk 
false not 
	-> true

true not 
	-> false
]]]

!! Exercise 2: Implement | (Or)
- Propose an implementation of or in a world where you do not have Booleans.
- You only have objects and messages.

[[[language=smalltalk 
	true | true -> true
	true | false -> true
	true | anything -> true

	false | true -> true
	false | false -> false
	false | anything -> anything
]]]

!! Exercise2: Variation - Implement ifTrue:ifFalse:
- Propose an implementation of not in a world where you do not have Booleans.
- You only have objects, messages and closures.

[[[language=smalltalk 
false ifTrue: [ 3 ] ifFalse: [ 5 ]
-> 5
true ifTrue: [ 3 ] ifFalse: [ 5 ]
-> 3
]]]


!! Booleans Implementation Hint One

- The solution does not use conditionals 
- else we would obtain a recursive definition of ==ifTrue:ifFalse:==

!! Boolean Implementation Hint Two

- The solution uses three classes: ==Boolean==, ==True== and ==False==
- ==false== and ==true== are unique instances described by their own classes 
- ==false== is an instance of the class ==False==
- ==true is an instance of the class ==True==

+Boolean Hierarchy>file://figures/BooleanHiearchyAndInstances.pdf+

!! How do we express choice in OOP?

- We send messages to objects

[[[language=smalltalk 
	aButton color
	-> Color red
	
	aPane color
	-> Color blue
	
	aWindow color
	-> Color grey
]]]

- Let's the receiver decide

- Do not ask, tell

!! Boolean not implementation

- Class ==Boolean== is an abstract class that implements behavior common to true and false. Its subclasses are ==True== and ==False==. Subclasses must implement methods for logical operations ==&==, ==not==, and controls ==and:==, ==or:==, ==ifTrue:==, ==ifFalse:==, ==ifTrue:ifFalse:==, ==ifFalse:ifTrue:==

[[[language=smalltalk
Boolean>>not
	"Negation. Answer true if the receiver is false, answer false if the receiver is true."
	self subclassResponsibility
]]]

!! Not implementation in two methods

[[[language=smalltalk 
False>>not
	"Negation -- answer true since the receiver is false."
	^ true
]]]

[[[language=smalltalk 
True>>not
	"Negation--answer false since the receiver is true."
	^ false
]]]

!! Not implementation in two methods
+Not implementation.>file://figures/BooleanHiearchyAndInstancesWithNotMethods.png+

!! | (Or)
[[[language=smalltalk 
	
	true | true -> true
	true | false -> true
	true | anything -> true

	false | true -> true
	false | false -> false
	false | anything -> anything

]]]

!! Boolean>> | aBoolean

[[[language=smalltalk 
	Boolean>> | aBoolean
		"Evaluating disjunction (OR). Evaluate the argument. Answer true if either the receiver or the argument is
true."
	self subclassResponsibility
]]]

!! False>> | aBoolean

[[[language=smalltalk 
false | true -> true
false | false -> false
false | anything -> anything
]]]

[[[language=smalltalk 
False >> | aBoolean
	"Evaluating disjunction (OR) -- answer with the argument, aBoolean."
	^ aBoolean 
]]]

!! True>> | aBoolean

[[[language=smalltalk 
true | true -> true
true | false -> true
true | anything -> true
]]]

[[[language=smalltalk 
True>> | aBoolean
	"Evaluating disjunction (OR) -- answer true since the receiver is true."
	^ self
]]]	

!! Or implementation in two methods

+>file://figures/BooleanHiearchyAndInstancesWithOrMethods.pdf+

!! Implementing ifTrue:ifFalse:

- Do you see the pattern?
- Remember that a closure freezes execution and that value launches the execution of a frozen code.

[[[
True>>ifTrue: aTrueBlock ifFalse: aFalseBlock
	^ aTrueBlock value
]]]

[[[
False>>ifTrue: aTrueBlock ifFalse: aFalseBlock
	^ aFalseBlock value
]]]



!! Implementation Note

- Note that the Virtual Machine shortcuts calls to boolean such as condition for speed reason.
- But you can implement your own conditional method and debug to see that sending a message is dispatching to the right object.


!! Ok so what?
- You will probably not implement another Boolean classes
- So is it really that totally useless?


!! Message sends act as case statements

- The execution engine will select the right method in the class of the receiver
- The case statements is dynamic in the sense that it depends on the classes loaded and the objects to which the message is sent.
- Each time you send a message, the system will select the method corresponding to the receiver.


!! A Class Hierarchy is a Skeleton for Dynamic Dispatch

- If we would have said that the ==Boolean== would be composed of only one class, we could not have use dynamic binding.
- A class hierarchy is the exoskeleton for dynamic binding

- Compare the solution with one class vs. a hierarchy.

+One single class vs. a nice hierarchy.>file://figures/Design-FatVsDispatch.pdf+

- The hierarchy provides a way to specialize behavior.
- It is also more declarative in the sense that you only focus on one class.
- It is more modular in the sense that you can package different classes in different packages.

!! Avoid Conditionals

- Use objects and messages, when you can
- The execution engine acts as a conditional switch: Use it!
- Check the AntiIfCampaign.

!! Follow-up: Implement ternary logic
- Boolean: ==true==, ==false==, ==unknown==
+Ternaru Logic decision table >file://figures/ArrayBoolean.png+

- Implementing in your own classes.


!! Summary
- Tell, do not ask
- Let the receiver decide
- Message sends as potential dynamic conditional
- Class hiearchy builds a skeleton for dynamic dispatch
- Avoid conditional