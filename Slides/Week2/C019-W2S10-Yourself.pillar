{
  "title":"Yourself",
  "slidesid":"W2S10"
}


${slide:title=A Puzzle and Candidate for Cascade}$

We add 2 to a set
[[[
   Set new add: 2
   > 2
]]]

We get 2 and not the set!

${slide:title=Why?}$

[[[
Set>>add: newObject
   "Include newObject as one of the receiver's elements, but only if not already present. Answer newObject."
   [...]
   ^ newObject
]]]

- The method ==add:== returns its argument, not the receiver
- Strange but this is like that!

${slide:title=A Verbose Solution}$

To get the collection back, we can use a temporary variable

[[[
   | s |
   s := Set new.
   s add: 1; add: 2.
   s
]]]

Do you see another solution?

${slide:title=One Hint}$

What if we get a message that returns the receiver?

${slide:title=yourself}$

[[[
Object >> yourself
   ^ self
]]]

${slide:title=A Puzzle: Solution}$

[[[
   | s |
   s := Set new.
   s add: 1; add: 2.
   s
]]]

is equivalent to

[[[
   Set new
      add: 1;
      add: 2;
      yourself
   > aSet
]]]

- ==add:== and ==yourself== are sent to the new ==Set==
- The cascade (;) returns the returned value of ==yourself==, hence the receiver


${slide:title=Another Idiom}$

[[[
MyClass >> new
  | instance |
  instance := super new.
  instance doSomething.
  ^ instance
]]]

is equivalent to

[[[
MyClass >> new
  ^ super new doSomething; yourself
]]]

Using ==yourself== makes sure that we return the instance and not the result of ==doSomething==

${slide:title=What You Should Know}$

- Some simple methods are powerful
- Cascade and ==yourself== plays well together


% Local Variables:
% compile-command: "cd ../.. && ./compile.sh --to=Beamer Slides/Week2/C019-W2S10-Yourself.pillar"
% End:
