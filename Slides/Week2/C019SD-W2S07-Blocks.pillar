{
  "title":"Introduction to Blocks"
}

${slide:title=Blocks}$

- blocks are kind of anonymous methods
-- sometimes called (lexical) closures
- used everywhere
-- loops, conditionals, iterators,...
-- GUI frameworks, DSLs,..
-- at the heart of Pharo
- just introduced in Java 8.0

${slide:title=Block Syntax}$

- a block is delimited by ==[ ]==

[[[
    [ expressions.... ]
]]]

${slide:title=A Block}$

- error signaled with ==(1 / 0)==
[[[
   ( 1 / 0 )
   -> Error
]]]
- no error signaled with ==[ 1 / 0 ]==

[[[
   [ 1 / 0 ]
   > [ 1 /0 ]
]]]

Nothing happens until a block is evaluated
- a block freezes the computation

${slide:title=Evaluating a Block}$

Evaluating a block is done ""explicitly"" through ==value==
[[[
   [ 2 + 6 ] value
   > 8
]]]

[[[
   [ 1 / 0 ] value
   > Error
]]]


${slide:title=A Block with 1 Argument}$

A bloc can take arguments (just like methods)

[[[
   [ :x | x + 2 ]
]]]

- ==[ ]== delimits the block
- == :x == is block argument
- == x + 2 == is the block body

[[[
   [ :x | x + 2 ] value: 5
   > 7
]]]

- ==value: 5== evaluates the block with 5 as argument
-- ==x== is 5 during the block evaluation

${slide:title=A Block with 2 Arguments}$

A bloc can take arguments (just like methods)

[[[
   [ :x :y | x + y ]
]]]

- ==[ ]== delimits the block
- == :x :y == are block arguments
- == x + y == is the block body

[[[
   [ :x :y | x + y ] value: 5 value: 7
   > 12
]]]

- ==value: 5 value: 7== evaluates the block with 5 and 7
-- ==x== is 5 and ==y== is 7 during the block evaluation


${slide:title=Block Evaluation Value}$

Block evaluation returns the value of the last expression
[[[
   [ :x |
      x + 33.
      x + 2 ] value: 5
   > 7
]]]

${slide:title=Blocks can be Stored}$

- a block can be stored in a variable
- a block can be evaluated multiple times

[[[
   | add2 |
   add2 := [ :x | x + 2 ].

   add2 value: 5
   > 7

   add2 value: 33
   > 35
]]]


${slide:title=A Design Advice}$

- use blocks with 2 or 3 arguments maximum
- define a class instead of a block for more arguments
- a block encapsulates only 1 computation
-- it cannot define more facets (e.g., printing)


${slide:title=Returning from a Block Returns from the Method}$

When a return ==^== is evaluated in a block, computation exits the encapsulating method

[[[
Integer>>factorial
   "Answer the factorial of the receiver."

   self = 0 ifTrue: [ ^ 1 ].
   self > 0 ifTrue: [ ^ self * (self - 1) factorial ].
   self error: 'Not valid for negative integers'
]]]

${slide:title=More Precisely}$

- when a return in a block is evaluated, computation returns from the method ""defining"" the block
- since blocks can be passed around in variables, blocks behave like an exception mechanism
- prefer exceptions
- pay attention when you put a return in a block.
- further readings: *http://deepintopharo.org*

${slide:title=Exercises}$

- Guess how to evaluate a block taking two arguments

[[[
   [ :x :y | x + y ]   5  7
   > 12
]]]


${slide:title=Other examples|label=expressLoop}$

[[[ 
   [ 2 + 3 + 4 + 5 ] value
   > 14
   [ :x | x + 3 + 4 + 5 ] value: 2
   > 14
   [ :x :y | x + y + 4 + 5] value: 2 value: 3
   > 14
]]]

${slide:title=Summary}$

[[[
   [ :variable1 :variable2 ... |
      | tmp |
      expression1.
      ...variable1 ...
      ]
      value: ... value: ...
]]]

- Approximately kind of an anonymous method 
- Technically lexical closures
- Can be passed as arguments to methods, stored in instance variables
- Basis of conditionals and loops (See companion lecture)
- Basis of iterators (See companion lecture)
- Further readings: *http://deepintopharo.org*

% Local Variables:
% compile-command: "cd ../.. && ./compile.sh --to=Beamer Slides/Week2/C019SD-W2S07-Blocks.pillar"
% End:
