{
	"title":"A glimpse at essential collections",
	"subtitle":"",
	"author":"StÃ©phane Ducasse",
	"complement":"http://stephane.ducasse.free.fr/ stephane.ducasse@inria.fr"
}

${slide:title=Collections In a Nutshell|label=arrays}$

- Pharo has a rich hierarchy of collection
- Common API: size, do:, select:, includes, collect:...
- Element 1 is at index 1
- Can contain any objects
- Most common ones:
-- ==Set== (no duplicates)
-- ==OrderedCollection== (dynamically growing)
-- ==Array== (fixed size, direct access)
-- ==Dictionary== (key-based)

${slide:title=Collections In a Nutshell|label=arrays}$

+>file://figures/CollectionHierarchyForIntroChapter.png|width=50+


${slide:title=Creating variable size objects|label=arrays}$

- Message ==new: size== creates an object of size

[[[language=smalltalk
    Array new: 4
    > #(nil nil nil nil)

    Array new: 2
    > #(nil nil)
	
    (OrderedCollection new: 1000) capacity
    > 1000
]]]

-Variants with value

[[[language=smalltalk
    OrderedCollection new: 5 withAll: 'a' 
    > "an OrderedCollection('a' 'a' 'a' 'a' 'a')"
]]]

${slide:title=Array|label=arrays}$

- ==#( ... )== 
- Fixed size

[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') size
    > 3

    #(45 38 1300 8) size
    > 4
]]]


${slide:title=Literals Arrays|label=arrays}$

[[[language=smalltalk
    #(45 38 1300 8) size
    > 4
]]]

- Literal version is read by the parser: elements are read when the array is created (the method is compiled)

- Equivalent to a dynamic version: elements are created at runtime. 
[[[language=smalltalk
    Array with: 45 with: 38 with: 1300 with: 8
]]]


${slide:title=Dynamic Array Syntactic Sugar|label=arrays}$

${slide:title=Literals Arrays|label=arrays}$

[[[language=smalltalk
    #(45 38 1300 8) 
    > #(45 38 1300 8) 
    Array with: 45 with: 38 with: 1300 with: 8
    > #(45 38 1300 8) 
]]]

- =={}== is syntactic sugar to create dynamic arrays

[[[language=smalltalk
    Array with: 45 with: 38 with: 1300 with: 8
    > #(45 38 1300 8)
    { 45 . 38 . 1300 . 8 } 
]]]

${slide:title=Literals vs. Dynamic Arrays|label=arrays}$

[[[language=smalltalk
    #(45 + 38 1300 8) 
    > #( 45 #+ 38 1300 8)
	
    #(45 + 38 1300 8) size
    > 5
]]]

[[[language=smalltalk
    Array with: 45 with: 38 with: 1300 with: 8
	
    { 45 + 38 . 1300 . 8 }
    > #( 83 . 1300 . 8)
]]]



${slide:title=First element starts at 1 |label=arrays}$

[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') at: 2
    > 'hates'
]]]


${slide:title= at: to access, at:put: to set|label=arrays}$


[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') at: 2 put: 'loves'
    > #('Calvin' 'loves' 'Suzie')
]]]

${slide:title=Variants|label=arrays}$

- An array of symbols:
[[[language=smalltalk
    #(#calvin #hobbes #suzie)	
    > #(#calvin #hobbes #suzie)	
    #(calvin hobbes suzie)
    > #(#calvin #hobbes #suzie)
]]]

- An array of strings:

[[[language=smalltalk
    #('calvin' 'hobbes' 'suzie')
    > #('calvin' 'hobbes' 'suzie')
]]]


${slide:title=Collection can contain heterogenous objects|label=arrays}$

- Heterogenous
[[[
 #('lulu' (1 2 3))
	-> #('lulu' #(1 2 3))
 #('lulu' 1.22 1)
	-> #('lulu' 1.22 1)
]]]


${slide:title=Byte Arrays |label=arrays}$

- ==#[1 2 255]==

{slide:title=OrderedCollection|label=arrays}$


{slide:title=Set|label=arrays}$

