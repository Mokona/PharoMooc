{
	"title":"Inheritance In Pharo in A Nushell",
	"subtitle":"",
	"author":"StÃ©phane Ducasse and Damien Cassou",
	"complement":"http://stephane.ducasse.free.fr/ stephane.ducasse@inria.fr"
}


${slide:title=In A Nutshell|label=Outline}$

- Single inheritance
-- Inheritance of instance variables is made at class definition time.
-- Inheritance of behavior is dynamic and done at runtime.
- Only virtual calls
- Method lookup starts in the class of the receiver
- ==self== represents the receiver, ==super== too. 
- Class methods are virtual too
- Messages not understood is a message and a hook of the metaobject protocol.


${slide:title=Root of Inheritance|label=Outline}$

- ==Object== is the root of normal classes.
- ==ProtoObject== the superclass of ==Object== is for special purposes:
-- ==ProtoObject=='s goal in life is to raise errors to most of the messages.
-- This is important to build proxies 


${slide:title=Inheritance of Instance Variables|label=Outline}$

- Inheritance of instance variables is made at class definition time.
-- The instance variables of a new class is computed based on its variables and the ones of its superclass.
-- This happens at class definition time.


${slide:title=Inheritance of Behavior|label=Outline}$

- Inheritance of behavior is dynamic and done at runtime.
- At runtime, the method corresponding to the message is looked up starting from the class of the receiver and follow the inheritance chain.

+>file://figures/LookupEssence.png|width=50+


${slide:title=self and super|label=Outline}$

- self and super represents the receiver of the message (as Java, C#....)
- super is used to access overriden methods. 


${slide:title=Lookup of class methods is no different}$

- Sending a message to a class is also late-bound (dynamically resolved)
-- contrary to Java/C#
-- no static, only methods of the class.

- Only one rule: when we send a message to an object, we look in the class of the object and follow the inheritance chain.

+>file://figures/LookupEssenceAny.png|width=40+


${slide:title=Lookup of class methods is no different}$

+>file://figures/MetaclassLookUp.png|width=70+






${slide:title=When message is not found|label=Inheritance}$

If no method is found and there is no superclass to explore (class Object), a new message called #doesNotUnderstand: is sent to the receiver, with a representation of the initial message.

+>file://figures/StepToDNU.png|width=50+

${slide:title=Step by Step...|label=Inheritance}$

- node1 print: aPacket
-- node is an instance of Node
-- ==print:== is looked up in the class Node
-- ==print:== is not defined in ==Node== > lookup continues in ==Object==
-- ==print:== is not defined in ==Object== => lookup stops.
-- system sends message: ==doesNotUnderstand: #(#print aPacket)== to ==node1==
-- ==node1== is an instance of ==Node== so ==doesNotUnderstand:== is looked up in the class ==Node==
-- ==doesNotUnderstand:== is not defined in ==Node== => lookup continues in ==Object==
-- ==doesNotUnderstand:== is defined in ==Object== => lookup stops \+ Exception -> Debugger

${slide:title=doesNotUnderstand: is a message|label=Inheritance}$

- ==doesNotUnderstand:== is a message
- Every class can customised error handling
- Important hook for
-- Proxies (a proxy raises error to most messages by being in subclass of ==ProtoObject== and doesNotUnderstand: get the control)

${slide:title=doesNotUnderstand: and the debugger|label=Inheritance}$

When you get an error, you get the debugger. But this is just a convenience when developing.
In fact:

- the message ==doesNotUnderstand:== is looked up,
- when no class redefines the message ==doesNotUnderstand:==
-- an exception (==MessageNotUnderstood==) is raised
-- if there is no handler of that exception 
-- the default behavior is to open a debugger
- This behavior can be customized at different points to hide/control/log errors.





${slide:title=What you should know|label=super}$

- Inheritance of instance variables is made at class definition time.
- Inheritance of behavior is dynamic and done at runtime.
- self **always** represents the receiver, the method lookup starts in the class of the receiver.
- super represents the receiver but method lookup starts in the superclass of the class using it.
- message not understood is a message and a hook of the metaobject protocol.
