{
    "title":"Class and Method Definitions",
	 "slidesid":"W1S06"
}

${slide:title=Class Definition}$

[[[
Object subclass: #NameOfSubclass
    instanceVariableNames: ''
    classVariableNames: ''
    package: 'PackageName'
]]]

${slide:title=Class Definition within the IDE}$

+>file://figures/PointClass.png|width=98+

${slide:title=Class Definition is Message :)}$

[[[
Object subclass: #Point
  instanceVariableNames: 'x y'
  classVariableNames: ''
  package: 'Graphics'
]]]

We send a message ==subclass:inst....== to the superclass to create the class




${slide:title=Method Definition}$

- Methods are public
- Methods are virtual (''i.e.,'' looked up at runtime)
- By default return ==self==

Template
[[[
messageSelectorAndArgumentNames
   "comment stating purpose of message"

  | temporary variable names |
  statements
]]]


${slide:title=Within the Browser part of the Pharo IDE}$

+>file://figures/FactorialInBrowser.png|width=98+

${slide:title=Presentation Convention}$

In this lecture, a method will be displayed as 

[[[
Integer >> factorial
  "Answer the factorial of the receiver."
  self = 0 ifTrue: [ ^ 1 ].
  self > 0 ifTrue: [ ^ self * (self - 1) factorial ].
  self error: 'Not valid for negative integers'
]]]

- ""Integer >>"" is not part of the syntax
-- it tells you the method's class



${slide:title=Remember Messages}$

[[[
Integer >> factorial
  "Answer the factorial of the receiver."

  self = 0 ifTrue: [ ^ 1 ].
  self > 0 ifTrue: [ ^ self * (self - 1) factorial ].
  self error: 'Not valid for negative integers'
]]]

- ==factorial== is the method name
- ==\===, ==>==, ==\*== and ==-== are binary messages
- ==^== is for returning a value
- ==factorial== is an unary message
- ==ifTrue:== and ==error:== are keyword messages sent to a boolean expression


${slide:title=Methods Return self by Default}$

[[[
Game >> initializePlayers
  self players
    at: 'tileAction'
    put: ( MITileAction director: self )
]]]

is equivalent to 

[[[
Game >> initializePlayers
  self players
    at: 'tileAction'
    put: ( MITileAction director: self )
  ^ self       "<-- this is optional"
]]]

${slide:title=Last Expression Is a Return}$

The last expression in a method is always a return

- Either added by you
[[[
Integer >> squared
  ^ self * self 
]]]

- or added by the compiler
[[[
Game >> initializePlayers
  self players
    at: 'tileAction'
    put: ( MITileAction director: self )
  ^ self       "<-- Added by the compiler"
]]]

${slide:title=Method Arguments are Read Only}$

- Do not try to assign a value to a method argument
- Arguments are read only!

[[[
MyClass >> setName: aString 
  aString := aString, 'Device'.
  ... aString ...
]]]

should be turned into 

[[[
MyClass >> setName: aString 
  | string |
  string :=  aString, 'Device'.
  ... string ...
]]]

${slide:title=Never overwrite methods starting with basic}$

Methods whose name starts with =='basic'== are important for the system
if you overwrite them wrongly, you can damage it



${slide:title=Class Methods}$

${columns}$

${column:width=60}$

+.>file://figures/classSideMethod.png|width=100+

${column:width=40}$

- press ==class side== to define a class method
- in lectures, we add ==class==

${endColumns}$

[[[
Point class >> x: xInteger y: yInteger 
  "Answer an instance of me with coordinates xInteger and yInteger."

  ^ self basicNew setX: xInteger setY: yInteger
]]]

${slide:title=What You Should Know}$

- Classes are defined inside packages
- Methods are public and virtual
- By default a method returns the receiver
- Class methods are just methods of the class

% Local Variables:
% compile-command: "cd ../.. && ./compile.sh --to=Beamer Slides/Week2/C019SD-W2S-ClassAndMethodDefinition.pillar"
% End:
