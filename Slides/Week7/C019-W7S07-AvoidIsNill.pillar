{
  "title":"Avoid Null Checks",
  "slidesid":"W7S07"
}

${slide:title=Design Again}$

- Not specific to Pharo 
- Object-Oriented Design is part of our DNA ;)

${slide:title=The Pitch}$

- Avoid null checks
- Null checks go against "Tell, do not ask" design guideline

Better
- Promote polymorphic objects once again
- Less checks, simpler logic, just send messages

+.>file://figures/antifIfCampaign.png|width=60+

${slide:title=First, Do Not Return Nil}$

- Do not force your clients to check
- Do not return nil AND another object
-- Not a collection and may be nil
-- Not a number and may be nil

${slide:title=Return Polymorphic Objects}$

- Return polymorphic objects!
- Return a collection and an empty collection
- Return a number and 0 or 1

${slide:title=Example}$

[[[
Inferencer >> getRulesFor: aFact
   ^ self computeRulesFor: aFact ifAbsent: [ nil ]
]]]

- ==ifAbsent: [ nil ]== looks suspicious! 

[[[
Inferencer >> computeRulesFor: aFact ifAbsent: aBlock
   self noRule ifTrue: [ ^ aBlock value ]
   ^ OrderedCollection with: self rules.
]]]

- ==getRulesFor:== returns either a collection or nil! 
- You force ""all"" the clients of ==getRulesFor:== to check for ==nil== values!

${slide:title=Solution: Return Polymorphic Objects}$

[[[
Inferencer >> getRulesFor: aFact
   ^ self computeRulesFor: aFact ifAbsent: [#()].
]]]

Your clients can just iterate and manipulate the returned value

[[[
(self getRulesForFact: 'a') do: [:each | ... ]
]]]

${slide:title=Second, For Exceptional Cases, Use Exceptions}$

- Avoid error codes, when possible :)
- If you should specify an exceptional behavior use exceptions.

[[[
[...] on: MyError do:[...]
[ ... ] on: FileStreamException do: [ ... ]
[ ... ] on: FileDoesNotExistException do: [ ... ]
]]]

${slide:title=Third, Initialize Your Object State}$

- By default instance variables are initialized with ==nil==
- Initialize your object state correctly

[[[
Archive >> initialize
   super initialize.
   members := OrderedCollection new.
]]]

${slide:title=Use Lazy Initialization If Necessary}$

[[[
FreeTypeFont >> descent
   ^ cachedDescent ifNil: [ 
        cachedDescent := (self face descender * self pixelSize // 
                               self face unitsPerEm) negated ]
]]]

- Do not forget to systematically use accessors

${slide:title=Sometimes you have to check ...}$

- Sometimes you have to check before doing some action
- If you can, turn the default case into an object (NullObject)

[[[
ToolPalette >> nextAction
   self selectedTool ifNotNil: [:t | t attachHandles]

ToolPalette >> previousAction
   self selectedTool ifNotNil: [:t | t dettachHandles]
]]]

${slide:title=NullObject}$

- A null object proposes a polymorphic API and embeds default actions/values
- Woolf, Bobby (1998). "Null Object". In Pattern Languages of Program Design 3. Addison-Wesley.

${slide:title=Use NullObject}$

[[[
NoTool >> attachHandles
   ^ self
]]]

[[[
NoTool >> detachHandles
   ^ self
]]]

[[[
ToolPalette >> initialize
   self selectedTool: NoTool new
]]]

[[[
ToolPalette >> nextAction
   self selectedTool attachHandles
]]]

[[[
ToolPalette >> previousAction
   self selectedTool detachHandles
]]]


${slide:title=Conclusion}$
- Messages act as a dispatcher
- Avoid conditionals
- Return polymorphic objects
- If you can define, create objects that represent default behavior
- When you can avoid it, avoid returning ==nil==
- Initialize your variables
