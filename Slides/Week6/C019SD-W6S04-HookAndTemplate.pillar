{
  "title":"Hooks and Templates",
  "subtitle":"An application of self-sends are plans for reuse",
  "slidesid":"W6S4"
}


${slide:title=Remember...}$

- Message passing is a choice operator
- Class hierarchies define choices
- Superclass code can be reused by subclasses 
- Sending messages in a superclass define places where subclass code can be injected.


${slide:title=Hooks/Template}$


- Template is the context that
-- defines hooks
-- is reused
- Hooks are places to be customized
-- Hook methods do not have to be abstract
-- May define default behavior or no behavior at all.

+>file://figures/hookAndTemplate.png|width=85+

${slide:title=printString Template}$

[[[
Object >> printString
  "Answer a String whose characters are a description of the receiver. If you want to print without a character limit, use fullPrintString."
  ^ self printStringLimitedTo: 50000
]]]

[[[
Object >> printStringLimitedTo: limit
  "Answer a String whose characters are a description of the receiver. If you want to print without a character limit, use fullPrintString."
  | limitedString |
  limitedString := String streamContents: [ :s | self printOn: s ] limitedTo: limit.
  limitedString size < limit ifTrue: [ ^ limitedString ].
  ^ limitedString , '...etc...'
]]]

${slide:title=printOn: Default Hook}$

[[[
Object >> printOn: aStream
  "Append to the argument, aStream, a sequence of characters that identifies the receiver."
  | title |
  title := self class name.
  aStream
      nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);
      nextPutAll: title
]]]

${slide:title=printOn: Hook Example}$

A simple redefinition
[[[
False >> printOn: aStream 
   aStream nextPutAll: 'false'
]]]



${slide:title=printOn: Hook Example}$

[[[
1 to: 100 
> (1 to: 100)
1 to: 100 by: 3 
> (1 to: 100 by: 3)
]]]

Simple: 
 
[[[
Interval >> printOn: aStream
   aStream nextPut: $(;
     print: start;
     nextPutAll: ' to: ';
     print: stop.
     step ~= 1 ifTrue: [ aStream nextPutAll: ' by: '; print: step ].
   aStream nextPut: $)
]]]

${slide:title=printOn: Hook Example}$

[[[
Association key: #January value: 31 
> #January->31 
]]]

Reusing and extending default behavior:
[[[
Association >> printOn: aStream
   super printOn: aStream.
   aStream nextPutAll: '->'.
   value printOn: aStream
]]]

${slide:title=Object Copy as Another Hook/Template}$

- Copying objects is complex:
-- Graph of connected objects
-- Cycles
-- Each object may want a different copy strategy
- Often the copy logic is encapsulated into a Copier
- Simple solution for simple cases: copy/postCopy hook and template


${slide:title=Copy as another Hook/Template}$

Copy is the smallest template method

[[[
Object >> copy
  "Answer another instance just like the receiver. Subclasses typically override postCopy. Copy is a template method in the sense of Design Patterns. So do not override it. Override postCopy instead. Pay attention that normally you should call postCopy of your superclass too."
    ^ self shallowCopy postCopy
]]]

[[[
Object >> shallowCopy
  "Answer a copy of the receiver which shares the receiver's instance variables. Subclasses that need to specialize the copy should specialize the postCopy hook method."
  <primitive: 148>
  ...
]]]

${slide:title=Default hook}$



[[[
Object >> postCopy
  "I'm a hook method in the sense of Design Patterns TemplateHook/Methods. I'm called by copy. self is a shallow copy, subclasses should copy fields as necessary to complete the full copy"
  ^ self 
]]]

${slide:title=postCopy: Hook Example}$

[[[
Bag >> postCopy
   super postCopy.
   contents := contents copy
]]]


${slide:title=postCopy: Hook Example}$

[[[
Dictionary >> postCopy
   "Must copy the associations, or later store will affect both the original and the copy"
   array := array collect: [ :association |
      association ifNotNil: [ association copy ] ]
]]]

${slide:title=Conclusion}$

- Common pattern
- Based on essential aspects of OOP
- self sends are hooks
- Each time you send a message, you increase potential reuse