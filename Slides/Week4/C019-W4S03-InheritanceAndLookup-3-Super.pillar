{
  "title":"Inheritance and Lookup",
  "subtitle":"3: Super",
  "slidesid" : "W4S03"
}

${slide:title=Goal}$

- Sending a message
- Dynamic binding/method lookup
- ==super== semantics and the differences with ==self==

${slide:title=What is Super?}$

Take 5 min and write the definition of super?

- Your definition should have two points:
-- What does it represent?
-- How the method are looked up when a message is sent to ==super==?


${slide:title=How Do We Access an Overriden Method?}$

- You define a method with the same name that one in an upper class.
- You want to execute it in your subclass?
- Use ==super== instead of ==self==

[[[
Workstation >> accept: aPacket
  (aPacket isAddressedTo: self)
     ifTrue: [ Transcript show: 'Accepted Workstation ', self name asString ]
     ifFalse: [ super accept: aPacket ]
]]]


${slide:title=Challenge Yourself With Super!}$

${columns}$

${column:width=80}$

+>file://figures/LookupWithSuperInSuperclassMethodThreeClasses.png|width=100+

${column:width=30}$

[[[
    A new bar
    > ...
    B new bar
    > ...
    C new bar
    > ...
]]]

${endColumns}$

${slide:title=Challenge Yourself With Super!}$

${columns}$

${column:width=80}$

+>file://figures/LookupWithSuperInSuperclassMethodThreeClasses.png|width=100+

${column:width=30}$

[[[
    A new bar
    > 10
    B new bar
    > 20
    C new bar
    > 100
]]]

${endColumns}$

${slide:title=Super Changes where the Lookup Starts}$

${columns}$

${column:width=36}$

+>file://figures/LookupWithSuperInSuperclassMethodThreeClasses.png|width=125+

[[[
    C new bar
    > 100
]]]

${column:width=68}$

- ==bar== is sent to ==aC== (instance of C): ==bar== is looked up in C, not found, look in ==B==
- ==bar== is found in class B, and applied to the receiver ==aC==.
- ==bar== is sent to ==super==,
- ==super== is the receiver (aC), but lookup starts above class ==B==
- ==bar== is found in class ==A== and it is applied to the receiver ==aC==.
- ==foo== is sent to ==self==: ==aC==
- ==foo== is found in class ==C== and applied to ==aC==, it returns 50.

${endColumns}$

${slide:title=Super? Super: the Receiver}$

- ==super== refers to the receiver of the message (like ==self==. Yes!)
- The method lookup starts in the superclass of ...?


${slide:title=Super Starts Lookup in Superclass of the Class Using It}$

- ==super== refers to the receiver of the message (like ==self==. Yes!)
- The method lookup starts in the superclass of ""the class containing the super expression""

${slide:title=Super is Static / Self is Dynamic}$

There is no reference to the receiver in the method lookup of a ==super== invocation!

${slide:title=Self is Dynamic}$

${columns}$

${column:width=50}$

- When we read the body of method ==bar==, there is no way that we know which method ==foo== will be executed.
- New instances of different classes can be created and the message ==bar== sent to them.
- ==self== acts as a hook. Code of subclasses can be injected into ==self== sends.

${column:width=50}$

+>file://figures/SelfIsDynamic1.png|width=110+

${endColumns}$

${slide:title=Super is Static}$

${columns}$

${column:width=50}$

+>file://figures/superIsStatic.png|width=90+

${column:width=50}$

At compilation-time, just reading the code we know that we should look above the class containing the ""method"" using ==super==.

${endColumns}$

${slide:title=Even Some Books Got it Wrong}$

- Wrong definition: super looks for the method in the superclass of the class of the ""receiver"".
- Wrong! It loops forever!
- ==aC foo== loops, because ==super== points to ==aC== and the superclass of the class of the receiver is ==B==.

+>file://figures/LookupWithWrongDefinition.png|width=65+




${slide:title=What You Should Know}$

- ==self== ''always'' represents the receiver
- Method lookup maps a message to a method
- Method lookup starts in the class of the receiver...
- ...and goes up in the hierarchy
- ==super== is the receiver, lookup starts is superclass of the method using the expression
- self sends act as a hook. Code of subclasses may be invoked.
