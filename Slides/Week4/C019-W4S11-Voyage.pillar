{
  "title":"Voyage: Document NoSQL",
  "slidesid" : "W4S011"
}

${slide:title=Goal}$

- To let you build a real little application
- Show you a nice way to store objects

${slide:title=MongoDB}$

- Document oriented, open-source NoSQL database
- Powerful query language
- Most popular document database so far 

${slide:title=What is Voyage?}$

- Object-Document Mapper for MongoDB
- Think on Hibernate for MongoDB
- For Pharo, obviously ;)

${slide:title=Voyage Feature}$

- Simple
- Ensure object identity
- Provide error-handling
- Implement a connection pool

${slide:title=Setting a Connexion}$

[[[
| repository |
repository := VOMongoRepository
    host: 'localhost'
    database: 'demo'.
repository enableSingleton.
]]]

${slide:title=Setting a In Memory Connexion}$

[[[
| repository |
repository := VOMemoryRepository new.
repository enableSingleton.
]]]

${slide:title=A Simple Model}$

+>file://figures/SuperHeroesModel.png|width=90+



${slide:title=A Simpler Model}$

+>file://figures/SuperHeroesModelSimpler.png|width=90+


${slide:title=A Simpler Model}$

[[[
Object subclass: #Hero
	instanceVariableNames: 'name level powers'
	classVariableNames: ''
	package: 'SuperHeroes'

Hero >> name
    ^ name
Hero >> name: aString    
    name := aString
Hero >> level
    ^ level
Hero >> level: anObject    
    level := anObject
Hero >> powers
    ^ powers ifNil: [ powers := Set new ]
Hero >> addPower: aPower
    self powers add: aPower
]]]

${slide:title=A Simpler Model}$

[[[
Object subclass: #Power
	instanceVariableNames: 'name'
	classVariableNames: ''
	category: 'Demo1'.

Power>>name
    ^ name
Power>>name: aString    
    name := aString
]]]


${slide:title=Root Classes}$

- Entry-point for our database
- Can be any class in the system
- Marked as root by ==isVoyageRoot== class method

${slide:title=Root Classes}$

[[[
Hero class >> isVoyageRoot
    ^ true
]]]

${slide:title=Some Heroes}$

[[[
Hero new 
    name: 'Spiderman';
    level: #epic;
    addPower: (Power new name: 'Super-strength');
    addPower: (Power new name: 'Wall-climbing');
    addPower: (Power new name: 'Spider instinct');
    save.

Hero new 
    name: 'Wolverine';
    level: #epic;
    addPower: (Power new name: 'Regeneration');
    addPower: (Power new name: 'Adamantium claws');
    save.
]]]


${slide:title=In DB}$

[[[
> db.Hero.find()[0]
{
	"_id" : ObjectId("d847065c56d0ad09b4000001"),
	"#version" : 688076276,
	"#instanceOf" : "Hero",
	"level" : "epic",
	"name" : "Spiderman",
	"powers" : [
		{
			"#instanceOf" : "Power",
			"name" : "Spider instinct"
		},
		{
			"#instanceOf" : "Power",
			"name" : "Super-strength"
		},
		{
			"#instanceOf" : "Power",
			"name" : "Wall-climbing"
		}
	]
}
]]]



${slide:title=Conclusion}$

- Messages sent to classes are resolved dynamically the same way as messages sent to instances
- Classes can then be used as registration mechanism


% Local Variables:
% compile-command: "cd ../.. && ./compile.sh --to=Beamer Slides/Week3/W3S8-ClassMethodsAtWork.pillar"
% End:
