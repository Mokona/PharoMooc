{
	"title":"An overview of essential collections"
}

${slide:title=What you will Learn}$

- The basic collections
- Essential API to program collections
- Difference between literal and dynamic arrays

${slide:title=Collection Common Attributes}$

- Pharo has a rich hierarchy of collection
- Common API: ==size==, ==do:==, ==select:==, ==includes:==, ==collect:==...
- First element is at index ==1==
- Can contain any object


${slide:title=Most Common Collections}$

- ==OrderedCollection== (dynamically growing)
- ==Array== (fixed size, direct access)
- ==Set== (no duplicates)
- ==Dictionary== (key-based, ''aka.'' maps)

${slide:title=Essential Collection In a Nutshell}$

+>file://figures/CollectionHierarchyForIntroChapter.png|width=110+


${slide:title=Common API Overview}$

- Most iterators work on all collections

#creation: ==with: anElement==, ==with:with:==, ==withAll: aCollection==
#accessing: ==size==, ==capacity==, ==at: anIndex==, ==at: anIndex put: anElement==
#testing: ==isEmpty==, ==includes: anElement==, ==contains: aBlock==, ==occurrencesOf: anElement==
#adding: ==add: anElement==, ==addAll: aCollection==
#removing: ==remove: anElement==, ==remove: anElement ifAbsent: aBlock==, ==removeAll: aCollection==
#enumerating: ==do: aBlock==, ==collect: aBlock==, ==select: aBlock==, ==reject: aBlock==, ==detect: aBlock==, ...
#converting: ==asBag==, ==asSet==, ==asOrderedCollection==, ==asSortedCollection==, ==asArray==

${slide:title=Variable Size Object Creation}$

- Message ==new== instantiates one object
- Message ==new: size== creates an object specifying its size

[[[
  Array new: 4
  > #(nil nil nil nil)
]]]

[[[
  Array new: 2
  > #(nil nil)
]]]

[[[	
  (OrderedCollection new: 1000) capacity
  > 1000
]]]

${slide:title=With Specific Elements}$

[[[	
  OrderedCollection withAll: #(7 3 13)
  > an OrderedCollection(7 3 13)
]]]

[[[	
  Set withAll: #(7 3 13)
  a Set( 7 3 13)
]]]

${slide:title=Creation  with Default Value}$

[[[
  OrderedCollection new: 5 withAll: 'a' 
  > an OrderedCollection('a' 'a' 'a' 'a' 'a')
]]]


${slide:title=First Element Starts At 1}$

[[[
  #('Calvin' 'hates' 'Suzie') at: 2
  > 'hates'
	
  #('Calvin' 'hates' 'Suzie') asOrderedCollection  at: 2 
  > 'hates'
]]]


${slide:title=Arrays}$

- Fixed size collection
- Direct access: ==at:== and ==at:put:==
- Has literal syntax: ==#( ... )== 
- Can also be created using ==new:== 

[[[
  #('Calvin' 'hates' 'Suzie') size
  > 3
]]]

is equivalent to 

[[[
  ((Array new: 3) 
    at: 1 put: 'Calvin'; 
    at: 2 put: 'hates'; 
    at: 3 put: 'Suzie') size
  > 3
]]]



${slide:title=Accessing Elements}$

Returning the size of the collection
[[[
  #('Calvin' 'hates' 'Suzie') size
  > 3
]]]

Accessing the 2nd element of the receiver using ==at: anIndex==
[[[
  #('Calvin' 'hates' 'Suzie') at: 2
  > 'hates'
]]]

- Remember collection index starts at 1

[[[
  #('Calvin' 'hates' 'Suzie') at: 55
  > Error
]]]


${slide:title=Changing Elements}$

Use the message ==at: anIndex put: anObject== 

Accessing the second element of the receiver
[[[
  #('Calvin' 'hates' 'Suzie') at: 2 put: 'loves'
]]]


${slide:title=Literal Arrays}$

- Literal arrays contain objects that have a textual (literal) representation: numbers, strings, nil, symbols

[[[
  #(45 'milou' 1300 true #tintin)
  > #(45 'milou' 1300 true #tintin)
]]]

- They are still instances of the class ==Array==

[[[
  #(45 38 1300 8) class
  > Array
]]]





${slide:title=Literals Arrays are Array Instances}$

Literal arrays are equivalent to a dynamic version.

A literal array
[[[
  #(45 38 1300 8) 
  > #(45 38 'milou' 8) 
]]]

An array
[[[
  Array with: 45 with: 38 with: 'milou' with: 8
  > #(45 38 'milou' 8) 
]]]

${slide:title=Nested Arrays}$

() inside a literal array produces a nested literal array.

[[[
  #((10@20) . (10@20))
  > #(#(10 #@ 20) #'.' #(10 #@ 20))
]]]

[[[
  #((10@20) . (10@20)) first class
	> Array
]]]



${slide:title=Array Short Syntax}$

Defining array is tedious 
[[[
  | array | 
  array := (Array new: 2). 
  array 
     at: 1 put: (Point x: 10 y: 20); 
     at: 2 put: (Point x: 10 y: 20).
   array
]]]

=={ element1 . element2 }== is syntactic sugar to create arrays

[[[
  {(10@20) . (10@20)}
  {Point x: 10 y: 20 . Point x: 10 y: 20}
]]]

${slide:title=Literal Array Creation Time}$

Literal arrays are created by the parser: when the expression is read, i.e. when the method is compiled, not the method is executed.

[[[
	| a |
	a := 12.
	#(a 13) 
	> #(#a 13)
]]]

Dynamic arrays are created during execution
[[[
	| a |
	a := 12.
	{a . 13} 
	> #(12 . 13)
]]]



${slide:title= Literal vs Dynamic}$

=={}== executes expressions while ==#()== not.
	
[[[
  {(10@20) . (10@20)} size 
  > 2
  {(10@20) . (10@20)}
  > {(10@20) . (10@20)}
]]]

[[[
  #((10@20) . (10@20)) size 
  > 3
  #((10@20) . (10@20))
  > #(#(10 #@ 20) #'.' #(10 #@ 20))
]]]




${slide:title= No Message Execution in Literal Array}$

There is no message executed when a literal array is created. 
[[[
  #(45 + 38 1300 8) 
  > #( 45 #+ 38 1300 8)
]]]

Arrays created with message sends are created during program execution.
[[[
  Array with: 45 + 38 with: 1300 with: 8
  > #( 83 . 1300 . 8)

  { 45 + 38 . 1300 . 8 }
  > #( 83 . 1300 . 8)
]]]



${slide:title=Variants}$

- An array of symbols:
[[[
  #(#calvin #hobbes #suzie)	
  > #(#calvin #hobbes #suzie)	
]]]

- An array of strings:
[[[
  #('calvin' 'hobbes' 'suzie')
  > #('calvin' 'hobbes' 'suzie')
]]]

${slide:title=Collection can contain heterogenous objects|label=arrays}$

- Heterogenous
[[[
  #('calvin' (1 2 3))
  > #('calvin' #(1 2 3))
	
  #('lulu' 1.22 1)
  > #('lulu' 1.22 1)
]]]

${slide:title=Byte Arrays |label=arrays}$
- Fixed size arrays.
- Elements are integers between 0 and 255.
- Has a special syntax: ==#[ 1 2 255 ]==

${slide:title=OrderedCollection|label=arrays}$

- Growing size
- ==add:==, ==remove:==

[[[
  | ordCol |
  ordCol := OrderedCollection new.
  ordCol add: 'Reef'; add: 'Pharo'; addFirst: 'Pharo'.
  ordCol 
  > an OrderedCollection('Pharo' 'Reef' 'Pharo')
	ordCol add: 'Seaside'.
	ordCol
	> an OrderedCollection('Pharo' 'Reef' 'Pharo' 'Seaside')
]]]

[[[
  #('Pharo' 'Reef' 'Pharo' 'Pharo') asOrderedCollection
  > an OrderedCollection('Pharo' 'Reef' 'Pharo' 'Pharo')
]]]

${slide:title=Set|label=set}$

- No duplicates
- Growing size
- ==add:==, ==remove:==

[[[
  #('Pharo' 'Reef' 'Pharo' 'Pharo') asSet
  >  a Set('Pharo' 'Reef')
]]]


${slide:title=Dictionary|label=set}$

- Key/values
- Growing size
- Accessing ==at:==, ==at:ifAbsent:==
- Changing/adding ==at:put:==, ==at:ifAbsentPut:== 
- iterating: ==do:==, ==keysDo:==, ==keysAndValuesDo:==

${slide:title=Dictionary creation|label=set}$

[[[
	| days |
	days := Dictionary new. 
	days 	
		at: #January put: 31;
		at: #February put: 28;
		at: #March put: 31.	
]]]

[[[
	days at: #January 
	> 31 

	days at: #NoMonth
	> KeyNotFound Error

	days at: #NoMonth ifAbsent: [0]
	> 0 
]]]

${slide:title=Dictionary iteration}$

[[[
days do: [ :each | Transcript show: each ;cr ] 
]]]

prints the days

[[[
Dictionary >> do: aBlock

		^self valuesDo: aBlock
]]]

[[[
days keysAndValuesDo: 
	[ :k :v | Transcript show: k asString, ' has ',  v printString, ' days' ; cr ] 
]]]

shows: 
[[[
	January has 31 days
	February has 28 days
	March has 31 days
]]]



${slide:title=Summary|label=set}$

- Easy to use collections.
- Common vocabulary.
- Simple conversion between them.

