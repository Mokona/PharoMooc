{
  "title":"An overview of essential collections"
}

${slide:title=What you will Learn}$

- The basic collections
- Essential API to program collections
- Difference between literal and dynamic arrays

${slide:title=Collection Common Attributes}$

- Pharo has a rich hierarchy of collection
- Common API: ==size==, ==do:==, ==select:==, ==includes:==, ==collect:==...
- First element is at index ==1==
- Can contain any object


${slide:title=Most Common Collections}$

- ==OrderedCollection== (dynamically growing)
- ==Array== (fixed size, direct access)
- ==Set== (no duplicates)
- ==Dictionary== (key-based, ''aka.'' maps)

${slide:title=Essential Collection In a Nutshell}$

+>file://figures/CollectionHierarchyForIntroChapter.png|width=110+


${slide:title=Common API Overview}$

- Most iterators work on all collections

#creation: ==with: anElement==, ==with:with:==, ==withAll: aCollection==
#accessing: ==size==, ==capacity==, ==at: anIndex==, ==at: anIndex put: anElement==
#testing: ==isEmpty==, ==includes: anElement==, ==contains: aBlock==, ==occurrencesOf: anElement==
#adding: ==add: anElement==, ==addAll: aCollection==
#removing: ==remove: anElement==, ==remove: anElement ifAbsent: aBlock==, ==removeAll: aCollection==
#enumerating: ==do: aBlock==, ==collect: aBlock==, ==select: aBlock==, ==reject: aBlock==, ==detect: aBlock==, ...
#converting: ==asBag==, ==asSet==, ==asOrderedCollection==, ==asSortedCollection==, ==asArray==

${slide:title=Variable Size Object Creation}$

- Message ==new== instantiates one object
- Message ==new: size== creates an object specifying its size

[[[
  Array new: 4
  > #(nil nil nil nil)
]]]

[[[
  Array new: 2
  > #(nil nil)
]]]

[[[  
  (OrderedCollection new: 1000) capacity
  > 1000
]]]

${slide:title=With Specific Elements}$

[[[  
  OrderedCollection withAll: #(7 3 13)
  > an OrderedCollection(7 3 13)
]]]

[[[  
  Set withAll: #(7 3 13)
  > a Set( 7 3 13)
]]]

${slide:title=Creation  with Default Value}$

[[[
  OrderedCollection new: 5 withAll: 'a' 
  > an OrderedCollection('a' 'a' 'a' 'a' 'a')
]]]


${slide:title=First Element Starts At 1}$

[[[
  #('Calvin' 'hates' 'Suzie') at: 2
  > 'hates'
  
  #('Calvin' 'hates' 'Suzie') asOrderedCollection  at: 2 
  > 'hates'
]]]

${slide:title=Collection can be heterogenous |label=arrays}$

Collections can contain any sort of objects.

[[[
  #('calvin' (1 2 3))
  > #('calvin' #(1 2 3))
]]]
- An array a string and a collection

[[[
  | s |
  s := Set new. 
  s add: Set new; 
    add: 1;
    add: 2.
  s asArray 
]]]
- A set containing a set and some numbers


${slide:title=Iteration}$

- Using message ==do: aBlock==
- But many iterators (see Iterators)
[[[
  #('Calvin' 'hates' 'Suzie') do: [ :each | Transcript show: each ]
]]]

+>file://figures/doTranscript.png|width=110+

${slide:title=Arrays}$

- Fixed size collection
- Direct access: ==at:== and ==at:put:==
- Has literal syntax: ==#( ... )== 
- Can also be created using ==new:== 

[[[
  #('Calvin' 'hates' 'Suzie') size
  > 3
]]]

is equivalent to 

[[[
  ((Array new: 3) 
      at: 1 put: 'Calvin'; 
      at: 2 put: 'hates'; 
      at: 3 put: 'Suzie') size
  > 3
]]]



${slide:title=Accessing Elements}$

The size of the collection
[[[
  #('Calvin' 'hates' 'Suzie') size
  > 3
]]]

Accessing the 2nd element using ==at: anIndex==
[[[
  #('Calvin' 'hates' 'Suzie') at: 2
  > 'hates'
]]]

Remember collection index starts at 1

${slide:title=Accessing Elements}$

[[[
  #('Calvin' 'hates' 'Suzie') at: 55
  > SubscriptOutOfBounds Error
]]]


${slide:title=Changing Elements}$

Use the message ==at: anIndex put: anObject== 

Changing the second element of the receiver
[[[
  #('Calvin' 'hates' 'Suzie') at: 2 put: 'loves'
  > #('Calvin' 'loves' 'Suzie')
]]]


${slide:title=Literal Arrays}$

Literal arrays contain objects that have a textual (literal) representation: numbers, strings, nil, symbols

[[[
  #(45 'milou' 1300 true #tintin)
  > #(45 'milou' 1300 true #tintin)
]]]

They are instances of the class ==Array==

[[[
  #(45 38 1300 8) class
  > Array
]]]





${slide:title=Literals Arrays are Array Instances}$

Literal arrays are equivalent to a dynamic version.

A literal array
[[[
  #(45 38 1300 8) 
  > #(45 38 'milou' 8) 
]]]

An array
[[[
  Array with: 45 with: 38 with: 'milou' with: 8
  > #(45 38 'milou' 8) 
]]]

${slide:title=Nested Arrays}$

==()== inside a literal array produces a nested literal array.

[[[
  #((10@20) . (10@20))
  > #(#(10 #@ 20) #'.' #(10 #@ 20))
]]]

[[[
  #((10@20) . (10@20)) first class
  > Array
]]]



${slide:title=Dynamic Array Short Syntax}$

Defining array is tedious 
[[[
  | array | 
  array := (Array new: 2). 
  array 
     at: 1 put: (Point x: 10 y: 20); 
     at: 2 put: (Point x: 10 y: 20).
   array
]]]

=={ element1 . element2 }== is syntactic sugar to create arrays

[[[
  {(10@20) . (10@20)}
  {Point x: 10 y: 20 . Point x: 10 y: 20}
]]]

${slide:title=Literal Array Creation Time}$

Literal arrays are created by the parser: when the expression is read, i.e. when the method is compiled, not the method is executed.

[[[
  | a |
  a := 12.
  #(a 13) 
  > #(#a 13)
]]]

Dynamic arrays are created during execution
[[[
  | a |
  a := 12.
  {a . 13} 
  > #(12 . 13)
]]]



${slide:title= Literal vs Dynamic}$

=={}== executes expressions while ==#()== not.
  
[[[
  {(10@20) . (10@20)} size 
  > 2
 
  #((10@20) . (10@20)) size 
  > 3
]]]

[[[
  {(10@20) . (10@20)}
  > {(10@20) . (10@20)}
  
  #((10@20) . (10@20))
  > #(#(10 #@ 20) #'.' #(10 #@ 20))
]]]




${slide:title= No Message Execution in Literal Array}$

There is no message executed when a literal array is created. 
[[[
  #(45 + 38 1300 8) 
  > #( 45 #+ 38 1300 8)
]]]

Arrays created with message sends are created during program execution.
[[[
  Array with: 45 + 38 with: 1300 with: 8
  > #( 83 . 1300 . 8)

  { 45 + 38 . 1300 . 8 }
  > #( 83 . 1300 . 8)
]]]



${slide:title=Literal Array Variants}$

- An array of symbols:
[[[
  #(#calvin #hobbes #suzie)  
  > #(#calvin #hobbes #suzie)  
]]]

- An array of strings:
[[[
  #('calvin' 'hobbes' 'suzie')
  > #('calvin' 'hobbes' 'suzie')
]]]



${slide:title=Byte Arrays}$
- Fixed size arrays
- Elements are integers between 0 and 255
- Has a special syntax: ==#[ 1 2 255 ]==

${slide:title=OrderedCollection}$

- Sequenceable
- Growing size
- ==add:==, ==remove:==

[[[
  | ordCol |
  ordCol := OrderedCollection new.
  ordCol add: 'Reef'; add: 'Pharo'; addFirst: 'Pharo'.
  ordCol 
  > an OrderedCollection('Pharo' 'Reef' 'Pharo')
  ordCol add: 'Seaside'.
  ordCol
  > an OrderedCollection('Pharo' 'Reef' 'Pharo' 'Seaside')
]]]

${slide:title=Conversion}$

[[[
  #('Pharo' 'Reef' 'Pharo' 'Pharo') asOrderedCollection
  > an OrderedCollection('Pharo' 'Reef' 'Pharo' 'Pharo')
]]]

${slide:title=Set}$

- No duplicates
- Growing size
- ==add:==, ==remove:==
- Can contain any object including other Sets
[[[
  #('Pharo' 'Reef' 'Pharo' 'Pharo') asSet
  >  a Set('Pharo' 'Reef')
]]]

${slide:title=Conversion}$

Collections can be converted simply to other collections
[[[
  asOrderedCollection

  asSet

  asArray
]]]


${slide:title=Dictionary}$

- Key/values
- Growing size
- Accessing ==at:==, ==at:ifAbsent:==
- Changing/adding ==at:put:==, ==at:ifAbsentPut:== 
- iterating: ==do:==, ==keysDo:==, ==keysAndValuesDo:==

${slide:title=Dictionary creation}$

[[[
  | days |
  days := Dictionary new. 
  days   
    at: #January put: 31;
    at: #February put: 28;
    at: #March put: 31.  
]]]

[[[
  days at: #January 
  > 31 

  days at: #NoMonth
  > KeyNotFound Error

  days at: #NoMonth ifAbsent: [0]
  > 0 
]]]

${slide:title=Dictionary iteration}$

[[[
days do: [ :each | Transcript show: each ;cr ] 
]]]

prints
[[[
  31
  28
  31
]]]
Why? 
Because
[[[
Dictionary >> do: aBlock

  ^self valuesDo: aBlock
]]]

${slide:title=Dictionary iteration}$

[[[
days keysAndValuesDo: 
  [ :k :v | Transcript show: k asString, ' has ',  v printString, ' days' ; cr ] 
]]]

shows: 
[[[
  January has 31 days
  February has 28 days
  March has 31 days
]]]



${slide:title=Summary}$

- Easy to use collections
- Common vocabulary
- Simple conversion between them

