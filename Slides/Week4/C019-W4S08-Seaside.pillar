{
  "title":"Seaside: An Innovative Web Application Framework",
  "slidesid" : "W4S08"
}

${slide:title=Seaside}$

- A powerful, innovative and flexible framework
- Dedicated to build complex Web applications
- Live coding and debugging 
- Support reusable Web components 
- Secure by default
- Web 2.0 support (Ajax, Reef, ...)
- REST integration

+>file://figures/SeasideLogo.png|width=80+

${slide:title=Books and Tutorials}$

- Seaside *http://www.seaside.st*
- Seaside book *http://book.seaside.st*
- Seaside tutorial *http://www.swa.hpi.uni-potsdam.de/seaside/*
- Seaside tutorial *http://seaside.gemtalksystems.com/tutorial.html*
- TinyBlog tutorial 

- Community: register to seaside mailing list and ask questions


${slide:title=Seaside Little History}$

- Developed by A. Briant and J. Fitzell
- Enhanced by L. Renggli and P. Marshall
- In production since 2002
- Actively maintained by J. Brichau, S. Eggermont (web site under full rewrite) 
- Foundation of many Pharo success stories 
- *http://www.pharo.org/success*


${slide:title=Seaside in a Nutshell}$

- Define reusable and stateful components
- Use a DSL for rendering components
- Compose components
-- build coarser-grained components by encaspulation
-- schedule components with ==call:== and ==answer:== messages
- A web application is just a root component  
- Debug your application on the fly
- Use metadata to generate forms

${slide:title=Seaside in production since 2002}$

+>file://figures/Seaside-Success.png|width=90+

${slide:title=Cable eXpertise}$

+>file://figures/Seaside-CableXP.png|width=110+

${slide:title=Quuve - debrispublishing.com}$

+>file://figures/Seaside-Quuve2.jpg|width=110+

% ${slide:title=YesPlan.be}$
% +>file://figures/Seaside-YesPlan2.png|width=110+

${slide:title=Seaside Components}$

- A component is:
-- an instance of a subclass of ==WAComponent==
-- a reusable and stateful part of a Web page
-- rendered in HTML (<div>)

-A Web application has a root component

[[[
WAAdmin register: WACounter asApplicationAt: 'Counter'.
]]]

${slide:title=The Counter Web application}$

+>file://figures/SeasideWACounter.png|width=70+

${slide:title=WACounter}$

[[[
WAComponent subclass: #WACounter
	instanceVariableNames: 'count'
	classVariableNames: ''
	package: 'Seaside-Examples-Misc'.

WACounter >> initialize
	super initialize.
	count := 0

WACounter >> increase
	count := count + 1

WACounter >> decrease
	count := count - 1
]]]

${slide:title=From components to valid HTML}$

- All components respond to ==renderContentOn:== 
- This method converts a component to valid HTML
- This message is automatically sent to components by Seaside 


${slide:title=HTML Rendering}$

- ==renderContentOn:== is dedicated to HTML generation 
- parameter named ==html== (==WAHtmlCanvas==) defines a DSL like API to generate valid HTML 

[[[
WACounter >> renderContentOn: html
	html heading: count.
	html anchor
		callback: [ self increase ];
		with: '++'.
	html space.
	html anchor
		callback: [ self decrease ];
		with: '--'
]]]


${slide:title=Live Debugging}$

[[[
WACounter>>decrease
	self haltIf: (count-1 < 0).
	count := count - 1
]]]
		

${slide:title=Walking Application Stack}$

+>file://figures/SeasideDebuggingWACounter.png|width=85+

${slide:title=Did you see?!}$

- ""No"" manual request parsing
- ""No"" XML configuration files
- ""No"" file/page
- ""No"" hardcoding of next page
- ""Live Debugging"" 
-- use the debugger to modify objects and proceed to generate the HTML response


${slide:title=Rendering components}$

Using a DSL 
- Brushes to emit HTML
-- OO API to generate HTML
-- Generated HTML valid by construction
- CSS-based

${slide:title=Generating a Title}$

[[[
html div id: 'title'; with: 'Title'
]]]

[[[
<div id="title">Title</div>
]]]

${slide:title=Generating a List}$

[[[
html div id: 'list'; 
	with: [ 
		html span class: 'item'; with: 'Item 1'.
		html span class: 'item'; with: 'Item 2' ]
]]]

[[[
<div id="list">
	<span class="item">Item 1</span>
	<span class="item">Item 2</span>
	</div>
]]]

${slide:title=Generating a List}$

[[[
html unorderedList 
	id: 'list'; 
	with: [
		1 to: 5 do: [ :i |
		html listItem 
			class: 'item'; 
			with: 'Item ', i asString ]]
]]]

[[[
<ul id="list">
  <li class="item">Item 1</li>
  <li class="item">Item 2</li>
  <li class="item">Item 3</li>
  <li class="item">Item 4</li>
  <li class="item">Item 5</li>
</ul>
]]]

${slide:title=Twitter Bootstrap}$

+>file://figures/TwitterBootstrap.png|width=100+



${slide:title=Twitter Alerts!}$

+>file://figures/TwitterAlerts.png|width=100+

[[[
renderExampleOn: html
	html heading level: 2; with: 'Examples'.					
	html tbsAlert 
		beSuccess;
		with: [ html strong: 'Well done!'. html text: ' You successfully read this important alert message.' ].
	html tbsAlert 
		beInfo;
		with: [ html strong: 'Heads up!'. html text: ' This alert needs your attention, but it''s not super important.' ].
]]]

${slide:title=Twitter Buttons!}$

+>file://figures/TwitterButtons.png|width=60+ 

[[[
renderExampleOn: html

	html tbsButtonGroup: [ 
		html tbsButton beDefault; with: 'Left'.
		html tbsButton beDefault; with: 'Middle'.
		html tbsButton beDefault; with: 'Right' ].
]]]


${slide:title=Back Button}$

TODO


${slide:title=Stepping Back}$

- Don't think in terms of pages
- ""No"" URL fiddling
- ""No"" request parsing
- ""No"" routing
- ""No"" XML 
- but powerful!


${slide:title=Conclusion}$

- A Web application = a root component
- A Component is rendered in HTML 


% Local Variables:
% compile-command: "cd ../.. && ./compile.sh --to=Beamer Slides/Week3/W3S8-ClassMethodsAtWork.pillar"
% End:
