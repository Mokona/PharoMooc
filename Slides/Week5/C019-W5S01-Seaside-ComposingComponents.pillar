{
  "title":"Seaside: Composing components",
  "slidesid" : "W5S01"
}

${slide:title=Remember: Seaside}$

- Think in terms of ""reusable"" and ""stateful components""
- A web application = a root component
- Live Debugging
-- through the debugger, you can modify objects and proceed to generate the HTML response


${slide:title=Roadmap}$

3 mechanisms to reuse components:
- Components aggregation 
- The ==call:== / ==answer:== mechanism
- Definition of workflows (Task)

${slide:title=Roadmap}$

3 mechanisms to reuse components:
- ""Components aggregation""
- The ==call:== / ==answer:== mechanism
- Definition of workflows (Task)


${slide:title=Remember: Counter / TwitterCounter}$

${columns}$

${column:width=50}$

==WACounter==
+>file://figures/SeasideWACounter.png|width=90+


${column:width=50}$

==WATwitterCounter==
+>file://figures/SeasideCounterBootstrap.png|width=90+

${endColumns}$



${slide:title=How to Build a Multi-Counter Application?}$

==WAMultiCounter==
+>file://figures/SeasideMultiTwitterCounter.png|width=50+


${slide:title=WAMultiCounter}$

[[[
WAExampleComponent subclass: #WAMultiCounter
    instanceVariableNames: 'counters'
    classVariableNames: ''
    package: 'Seaside-Examples-Misc'.
	
WAMultiCounter >> initialize
    super initialize.
    counters := (1 to: 5) collect: [ :each | WACounter new ].

WAMultiCounter >> children
    ^ counters
		
WAMultiCounter >> renderContentOn: html
    counters do: [ :each | html render: each ]
]]]

${slide:title=How to Compose Components?}$

A composite:
- Stores subcomponents in an instance variable (e.g. ==counters==)
- Sends ==render:== to subcomponents in its ==renderContentOn:== method
- Redefines ==children== to return the collection of its subcomponents 

${slide:title=Aggregating Different Subcomponents}$

[[[
WAExampleComponent subclass: #MyApp
    instanceVariableNames: 'children'
    classVariableNames: ''
    package: 'Seaside-Examples-Misc'.

MyApp >> initialize
    super initialize.
    children := { Greeter new. 
		 WATwitterCounter new. WACounter new }.

MyApp >> children
    ^ children

MyApp >> renderContentOn: html
    children do: [ :each | html render: each ]
        separatedBy: [ html line ]
]]]

${slide:title=Aggregating Different Subcomponents}$

+>file://figures/SeasideDifferentSubcomponents.png|width=80+

${slide:title=Rendering Only One Subcomponent}$

${columns}$

${column:width=50}$

+>file://figures/SeasideMyApp.png|width=95+

${column:width=50}$

+>file://figures/SeasideMyApp2.png|width=95+

${endColumns}$

${slide:title=Rendering Only One Subcomponent}$

[[[
MyApp >> initialize
    "..."
	 selectedChild := children first

MyApp >> renderContentOn: html
	self renderMenuOn: html.
	html render: selectedChild 

MyApp >> renderMenuOn: html
    html unorderedList: [ 
        self children doWithIndex: [ :child :i |
            html listItem: [ 
                html anchor 
                    class: 'selected' if: child = currentComponnent ;
                    callback: [ selectedChild := self children at: i ];
						  with: child className  
    ] ] ]
]]]

${slide:title=Roadmap}$

3 mechanisms to reuse components:
- Components aggregation
- ""The ==call:== / ==answer:== mechanism""
- Definition of workflows (Task)


${slide:title=call:}$

+>file://figures/SeasideCall1.png|width=90+


${slide:title=call:}$

+>file://figures/SeasideCall2.png|width=90+


${slide:title=answer:}$

+>file://figures/SeasideAnswer1.png|width=90+

${slide:title=answer:}$

+>file://figures/SeasideAnswer2.png|width=100+



${slide:title=call:/answer:}$

Messages ==call:answer:== reintroduce PC after call on top of a stateless protocol



${slide:title=Roadmap}$

3 mechanisms to reuse components:
- Components aggregation
- The ==call:== / ==answer:== mechanism
- ""Definition of workflows (Task)""


${slide:title=A Task}$

Simple component
- No UI part
- Just flow
- Usually orchestrator between several components
-- it uses ==call:==/==answer:== behind the scene

${slide:title=A Simple Web Task}$

Will describe ==request:== implementation later

[[[
WATask subclass: #Adder
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'SeaExample'
]]]

[[[
Adder >> go
	| value1 value2 |
	value1 := self request: 'first number'.
	value2 := self request: 'second number'.
	self inform: value1 asNumber + value2 asNumber
]]]

[[[
WAAdmin register: self asApplicationAt: 'Adder'.
]]]

${slide:title=How request: is Implemented?}$

[[[
WAComponent >> request: aRequestString label: aLabelString default: aDefaultString onAnswer: aBlock
	"Display an input dialog with the question aRequestString, the button label aLabelString and the default string aDefaultString. Passes the answer into aBlock."
	
	self
		call: (WAInputDialog new
			addMessage: aRequestString;
			default: aDefaultString;
			label: aLabelString;
			yourself)
		onAnswer: aBlock	
]]]

- ==request:== uses ==call:== / ==answer:==

${slide:title=request: implementation}$

A reusable component ==answer:== a result

[[[
WAInputDialog >> renderContentOn: html
	html form
		defaultAction: [ self answer: value ];
		with: [
			html div: [
				html textInput on: #value of: self.
				html space.
				html submitButton
					callback: [ self answer: value ];
					text: self label ] ]
]]]


${slide:title=Debugger at Work}$

[[[
Adder >> go
	| value1 value2 |
	value1 := self request: 'first number'.
	1/0.
	value2 := self request: 'second number'.
	self inform: value1 asNumber + value2 asNumber
]]]

${slide:title=Triggering Server Side Debugger}$

+>file://figures/SeasideAdderWallback.png|width=160+



${slide:title=Walking Application Stack}$

+>file://figures/SeasideAdderDebugger.png|width=130+


${slide:title=So far...}$

- no manual request parsing
- no XML configuration files
- no file/page
- no hardcoding of next page


${slide:title=Stepping Back}$

- We don't think in terms of pages
- No URL fiddling
- No request parsing
- Component composition




${slide:title=Conclusion}$

- Messages sent to classes are resolved dynamically the same way as messages sent to instances
- Classes can then be used as registration mechanism


% Local Variables:
% compile-command: "cd ../.. && ./compile.sh --to=Beamer Slides/Week3/W3S8-ClassMethodsAtWork.pillar"
% End:
