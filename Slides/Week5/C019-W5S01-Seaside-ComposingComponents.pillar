{
  "title":"Seaside: Composing components",
  "slidesid" : "W5S01"
}

${slide:title=Remember: Seaside}$

- ...

+>file://figures/SeasideLogo.png|width=80+

${slide:title=Reusing Components}$

- agregate components (children)
- call: / answer:
- define workflows (Task)


${slide:title=A Multi-Counter}$

+>file://figures/SeasideMultiCounter.png|width=50+


${slide:title=WAMultiCounter}$


[[[
	Code
]]]

${slide:title=WAMultiCounter using WATwitterCounter}$

+>file://figures/SeasideMultiTwitterCounter.png|width=50+



${slide:title=call:}$

+>file://figures/SeasideCall1.png|width=90+


${slide:title=call:}$

+>file://figures/SeasideCall2.png|width=90+


${slide:title=answer:}$

+>file://figures/SeasideAnswer1.png|width=90+

${slide:title=answer:}$

+>file://figures/SeasideAnswer2.png|width=100+



${slide:title=call:/answer:}$

Messages ==call:answer:== reintroduce PC after call on top of a stateless protocol


${slide:title=Back Button}$



${slide:title=A Task}$

Simple component
- No UI part
- Just flow
- Usually orchestrator between several components
-- use call:/answer: behind the scene

${slide:title=A Simple Web Task}$

Will describe ==request:== implementation later

[[[
WATask subclass: #Adder
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'SeaExample'
]]]

[[[
Adder >> go
	| value1 value2 |
	value1 := self request: 'first number'.
	value2 := self request: 'second number'.
	self inform: value1 asNumber + value2 asNumber
]]]

[[[
WAAdmin register: self asApplicationAt: 'Adder'.
]]]

${slide:title=How request: is Implemented?}$

[[[
WAComponent >> request: aRequestString label: aLabelString default: aDefaultString onAnswer: aBlock
	"Display an input dialog with the question aRequestString, the button label aLabelString and the default string aDefaultString. Passes the answer into aBlock."
	
	self
		call: (WAInputDialog new
			addMessage: aRequestString;
			default: aDefaultString;
			label: aLabelString;
			yourself)
		onAnswer: aBlock	
]]]

- ==request:== uses ==call:== / ==answer:==

${slide:title=request: implementation}$

A reusable component ==answer:== a result

[[[
WAInputDialog >> renderContentOn: html
	html form
		defaultAction: [ self answer: value ];
		with: [
			html div: [
				html textInput on: #value of: self.
				html space.
				html submitButton
					callback: [ self answer: value ];
					text: self label ] ]
]]]


${slide:title=Debugger at Work}$

[[[
Adder >> go
	| value1 value2 |
	value1 := self request: 'first number'.
	1/0.
	value2 := self request: 'second number'.
	self inform: value1 asNumber + value2 asNumber
]]]

${slide:title=Triggering Server Side Debugger}$

+>file://figures/SeasideAdderWallback.png|width=160+



${slide:title=Walking Application Stack}$

+>file://figures/SeasideAdderDebugger.png|width=130+


${slide:title=So far...}$

- no manual request parsing
- no XML configuration files
- no file/page
- no hardcoding of next page






${slide:title=Advanced Seaside}$




${slide:title=Component Automatic Generation}$



${slide:title=Stepping Back}$

- We don't think in terms of pages
- No URL fiddling
- No request parsing
- Component composition




${slide:title=Conclusion}$

- Messages sent to classes are resolved dynamically the same way as messages sent to instances
- Classes can then be used as registration mechanism


% Local Variables:
% compile-command: "cd ../.. && ./compile.sh --to=Beamer Slides/Week3/W3S8-ClassMethodsAtWork.pillar"
% End:
