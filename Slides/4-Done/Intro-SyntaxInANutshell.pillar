{
  "title":"Pharo Syntax in a Nutshell",
  "author":"St√©phane Ducasse",
  "complement":"http://www.pharo.org/"
}

${slide:title=Getting a Feel About the Syntax}$

In this lecture we want to give you the general feel to get started

- Overview of simple syntactical elements
- Message composition
- Overview of closure syntax

${slide:title=The Complete Syntax}$

[[[
exampleWithNumber: x
  "This method illustrates the complete syntax except primitive invocation."
  <aMethodAnnotation>

  | y |
  true & false not & (nil isNil)
    ifFalse: [ self halt ].
  y := self size + super size.
  #($a #a 'a' 1 1.0)
    do: [ :each | Transcript
            show: (each class name);
            show: (each printString);
            show: ' ' ].
  ^ x < y
]]]

${slide:title=Originally Made for Kids}$

- Read it as a non-computer-literate person:

[[[
| bunny |
bunny := Actor fromFile: 'bunny.vrml'.
bunny head doEachFrame:
  [ bunny head
      pointAt: (camera
        transformScreenPointToScenePoint: Sensor mousePoint
        using: bunny)
      duration: camera rightNow ]
]]]

${slide:title=Getting the Pharo Logo}$

[[[
  (ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
    asMorph openInWindow.
]]]

- Message ==getPng:== sent to the ==ZnEasy== class
- Messages ==asMorph== and ==openInWorld==
- Class names start with an uppercase character
- Keyword message ==getPng:==
- Unary messages ==asMorph== and ==openInWorld==


${slide:title=A Simple Method}$

[[[
Integer >> factorial
  "Answer the factorial of the receiver."
  self = 0 ifTrue: [ ^ 1 ].
  self > 0 ifTrue: [ ^ self * (self - 1) factorial ].
  self error: 'Not valid for negative integers'
]]]

${slide:title=A Simple Method}$

[[[
Integer >> factorial
  "Answer the factorial of the receiver."
  self = 0 ifTrue: [ ^ 1 ].
  self > 0 ifTrue: [ ^ self * (self - 1) factorial ].
  self error: 'Not valid for negative integers'
]]]

- ==Integer >> == is not part of the syntax:
-- it tells you the method's class
- ==factorial== is the method name
- ==\===, ==>==, ==\*== and ==-== are binary messages
- ==^== is for returning a value
- ==factorial== is an unary message
- ==ifTrue:== is a message sent to a boolean expression


${slide:title=Sending an HTTP Request}$

[[[
ZnClient new
  url: 'https://en.wikipedia.org/w/index.php';
  queryAt: 'title' put: 'Pharo';
  queryAt: 'action'  put: 'edit';
  get
]]]

- ==new== is a message sent to a class
- ==queryAt:put:== is a keyword message
- ==get== is a unary message
- ==;== sends all messages to the same receiver


${slide:title=Common Elements}$

- comment: =="a comment"==
- character: ==$c== ==$h== ==$a== ==$r== ==$a== ==$c== ==$t== ==$e== ==$r== ==$s== ==$#== ==$@==
- string: =='a nice string'== ==\'l\'\'idiot\'==
- symbol: ==#mac== ==#+==
- array: ==#(1 2 3 4)== ==#('b' 'c')==
- integer: ==1==, ==2r101==
- real: ==1.5==, ==6.03e-34==, ==4==, ==2.4e7==
- fraction: ==1/33==
- boolean: ==true==, ==false==
- point: ==10@120==

- Note that ==@== is not an element of the syntax, but just a message sent to a number. This is the same for ==/==, ==bitShift:==, ==ifTrue:==, ==do:== ...


${slide:title=Language Construct Overview}$

- =="..."==  comments
- ==\#== symbol or array
- =='...'== string
- ==$== character
- ==[ ]== block or byte array
- e, r number exponent or radix
- ==<annotation>== method annotation
- parenthesis: ==(...)==
- ==.== separator and not terminator
- ==;== cascade (sending several messages to the same object)

${slide:title=Essential Constructs}$

Elementary constructs
- temporary variable declaration: ==| tmp |==
- variable assigment: ==var \:= aValue==
- block (lexical closure): ==[:var ||tmp| expr...]==
- block argument: ==[ :var |==

${slide:title=Messages}$

Messages
- unary message: ==receiver selector==
- binary message: ==receiver selector argument==
- keyword-based message: ==receiver keyword1: arg1 keyword2: arg2...==
- cascade: == receiver selector ; selector ...==

Others
- separator: ==message . message==
- return: ==\^ expresion==


${slide:title=Conditionals are also Message Sends}$

[[[
Weather isRaining
  ifTrue: [ self takeMyUmbrella ]
  ifFalse: [ self takeMySunglasses ]
]]]

- ==ifTrue:ifFalse:== is sent to an object: a boolean!
- ==ifFalse:ifTrue:== also exists and also ==ifTrue:== and ==ifFalse:==


${slide:title=Loops are also Message Sends}$

[[[
1 to: 100 do: [ :i| Transcript << i ]
> 1
> 2
> 3
> 4
]]]
- ==to:do:== is a message sent to an integer (here a small integer)



${slide:title=With Iterators}$

[[[
#(1 2 -4 -86)
  do: [ :each | Transcript show: each abs printString ; cr ]
> 1
> 2
> 4
> 86
]]]

- Yes we ask the collection object to perform the iteration
- There are many other messages implementing loops! (==timesRepeat:==, ==do:==, ==to:by:do:==, ==whileTrue:==, ==whileFalse:==)

${slide:title=Messages and Their Composition}$

- Three kinds of messages
-- Unary: ==Node new==
-- Binary: ==1+2==, ==3@4==
-- Keywords: ==aTamagoshi eat: #cooky furiously: true==
- Message Priority
-- (Msg) > unary > binary > keywords
-- Same Level from left to right

${slide:title=Message Examples}$

[[[
(10@0 extent: 10@100) bottomRight
]]]
- Creates a rectangle and asks its bottom right corner

[[[
  (ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
    asMorph openInWindow.
]]]
- Fetches and open a figure

${slide:title=Blocks}$

- A kind of anonymous method
- Can be passed as method argument or stored in variables
- Functions

[[[
  fct(x)= x*x+3.
  fct(2).
]]]

[[[
  fct := [ :x | x * x + 3 ].
  fct value: 2
]]]

${slide:title=Block Usage}$

[[[
  #(1 2 3) do: [ :each | Transcript show: each printString ; cr ]
]]]

[[[
Integer >> factorial
  | tmp |
  tmp:= 1.
  2 to: self do: [ :i | tmp := tmp * i ]
]]]

${slide:title=Class Definition}$

[[[
Object subclass: #Point
  instanceVariableNames: 'x y'
  classVariableNames: ''
  category: 'Graphics'
]]]

${slide:title=Method Definition}$

- Normally defined in a browser or (by directly invoking the compiler)
- Methods are public
- By default return ==self==

[[[
Node >> dist: aPoint
  "Answer the distance between aPoint and the receiver."
  | dx dy |
  dx := aPoint x - x.
  dy := aPoint y - y.
  ^ (dx * dx + (dy * dy)) sqrt
]]]

${slide:title=Instance-Creation with Messages}$

- Messages sent to an instance
[[[
  '1', 'abc'
  1@2
]]]

- Basic instance-creation messages are ==new== and ==new:== sent to a class
[[[
  Monster new
  Array new: 6
]]]

- Specific instance-creation message (sent to a class)
[[[
  Tomagoshi withHunger: 10
]]]

${slide:title=Conclusion}$

- Compact syntax
- Few constructs but really expressive
- Support for Domain Specific Languages
- Mainly messages and closures

% Local Variables:
% compile-command: "cd ../.. && ./compile.sh --to=Beamer Slides/4-Done/Intro-SyntaxInANutshell.pillar"
% End:
