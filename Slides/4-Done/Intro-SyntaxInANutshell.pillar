{
    "title":"Pharo Syntax in a Nutshell",
    "author":"St√©phane Ducasse",
    "complement":"http://www.pharo.org/"
}

${slide:title=Getting a feel about the syntax}$

In this lecture we want to give you the general feel to get started
- Overview of simple syntactical elements
- Message composition
- Overview of closure syntax

${slide:title=The complete syntax}$

[[[language=smalltalk
exampleWithNumber: x
    "This method illustrates the complete syntax except primitive invocation."
    <aMethodAnnotation>
    
    | y |
    true & false not & (nil isNil) 
        ifFalse: [ self halt ]. 
    y := self size + super size.
    #($a #a 'a' 1 1.0)
        do: [ :each | Transcript
                        show: (each class name);
                        show: (each printString);
                        show: ' ' ].
    ^ x < y
]]]

method definition, argument, comment, annotation, variable declaration, true, false, nil, condition, message sequence, assignment, self, super, array, character, symobol, string, number, loops, block closure, keyword-based messages, return.

${slide:title=Originally Made for Kids|label=kids}$

- Read it as a non-computer-literate person:

[[[language=smalltalk
| bunny |
bunny := Actor fromFile: 'bunny.vrml'.
bunny head doEachFrame:
    [ bunny head
        pointAt: (camera 
                    transformScreenPointToScenePoint: Sensor mousePoint
                    using: bunny)
        duration: camera rightNow ]
]]]

${slide:title=Getting the Pharo Logo|label=kids}$

[[[language=smalltalk
    (ZnEasy getPng: 'http://pharo.org/web/files/pharo.png') 
        asMorph openInWindow.
]]]

- Send the message ==getPng:== to the class ==ZnEasy==, then send message ==asMorph== and ==openInWorld==.
- Class names start with an uppercase
- keyword message ==getPng:==
- unary messages ==asMorph== and ==openInWorld==


${slide:title=A Simple Method|label=factorial}$

[[[
Integer >> factorial
    "Answer the factorial of the receiver."
    self = 0 ifTrue: [ ^ 1 ].
    self > 0 ifTrue: [ ^ self * (self - 1) factorial ].
    self error: 'Not valid for negative integers'
]]]

${slide:title=A Simple Method|label=factorial}$

[[[
Integer >> factorial
    "Answer the factorial of the receiver."
    self = 0 ifTrue: [ ^ 1 ].
    self > 0 ifTrue: [ ^ self * (self - 1) factorial ].
    self error: 'Not valid for negative integers'
]]]

- ==Integer >> == is not part of the syntax.
- It is to tell you in the slides in which class the method is defined.
- ==factorial== is the method name
- ==\===, ==>==, ==*==, ==-== are binary messages.
- ==^== is for returning a value.
- ==factorial== is an unary message.
- ==ifTrue:== is a message sent to a boolean expression


${slide:title=Sending a request|label=ZnClient}$

[[[
ZnClient new
    url: 'http://localhost:8080/books/1';
    formAt: 'author' put: 'SquareBracketAssociates';
    formAt: 'title'  put: 'Pharo For The Enterprise';
    put
]]]

- ==new== is a message sent to a class
- ==formAt:put:== is a keyword message
- ==put== is a unary message
- ==;== is to send all the messages to the same receiver: an instance of ==ZnClient==


${slide:title=Common elements|label=syntax}$

- comment: "a comment"
- character: $c $h $a $r $a $c $t $e $r $s $# $@
- string: =='a nice string'== ==\'l\'\'idiot\'==
- symbol: #mac #+
- array: #(1 2 3 4) #('b' 'c')
- integer: 1, 2r101
- real: 1.5, 6.03e-34,4, 2.4e7
- float: 1/33
- boolean: true, false
- point: 10@120
-- Note that @ is not an element of the syntax, but just a message sent to a number. This is the same for /, bitShift, ifTrue:, do: ...


${slide:title=Language Construct Overview|label=block}$

- =="..."==    comments
- ==\#== symbol or array
- =='...'== string
- ==$== character
- ==[ ]== block or byte array
- e, r number exponent or radix
- ==<annotation>== method annotation
- parenthesis: (...)
- . separator and not terminator
- ; cascade (sending several messages to the same object)

${slide:title=Essential constructs|label=syntax}$

Elementary constructs
- temporary variable declaration: ==| tmp |==
- variable assigment: ==var \:= aValue==
- block (lexical closure): ==[:var ||tmp| expr...]==
- block argument: ==[ :var |==

${slide:title=Messages |label=syntax}$

Messages
- unary message: ==receiver selector==
- binary message: ==receiver selector argument==
- keyword-based message: ==receiver keyword1: arg1 keyword2: arg2...==
- cascade: == receiver selector ; selector ...==

Others
- separator: ==message . message==
- return: ==\^ expresion==


${slide:title=Conditionals are also message sends|label=conditional}$

[[[language=smalltalk
Weather isRaining
    ifTrue: [ self takeMyUmbrella ]
    ifFalse: [ self takeMySunglasses ]
]]]

- ==ifTrue:ifFalse:== is sent to an object: a boolean!
- ==ifFalse:ifTrue:== also exists and also ==ifTrue:== and ==ifFalse:==


${slide:title=Loops are also message sends|label=conditional}$

[[[language=smalltalk
1 to: 100 do: [ :i| Transcript << i ]
> 1
> 2
> 3
> 4
]]]
- ==to:do:== is a message sent to an integer (here a small integer)



${slide:title=With iterators|label=conditional}$

[[[language=smalltalk
#(1 2 -4 -86)
    do: [ :each | Transcript show: each abs printString ; cr ]
> 1
> 2
> 4
> 86
]]]

- Yes we ask the collection object to perform the iteration
- There are many other messages implementing loops! (==timesRepeat:==, ==do:==, ==to:by:do:==, ==whileTrue:==, ==whileFalse:==)

${slide:title=Messages and their composition|label=conditional}$

- Three kinds of messages
-- Unary: ==Node new==
-- Binary: ==1+2==, ==3@4==
-- Keywords: ==aTamagoshi eat: #cooky furiously: true==
- Message Priority
-- (Msg) > unary > binary > keywords
-- Same Level from left to right

${slide:title=Message Examples|label=conditional}$

[[[language=smalltalk
(10@0 extent: 10@100) bottomRight
]]]
- Creates a rectangle and asks its bottom right corner

[[[language=smalltalk
    (ZnEasy getPng: 'http://pharo.org/web/files/pharo.png') 
        asMorph openInWindow.
]]]
- Fetches and open a figure

${slide:title=Blocks|label=blocks}$

- A kind of anonymous method
- Can be passed as method argument or stored in variables
- Functions

[[[language=smalltalk
    fct(x)= x*x+3.
    fct(2).
]]]

[[[language=smalltalk
    fct := [ :x | x * x + 3 ].
    fct value: 2
]]]

${slide:title=Block Usage |label=blocks}$

[[[language=smalltalk
    #(1 2 3) do: [ :each | Transcript show: each printString ; cr ]
]]]

[[[language=smalltalk  
Integer >> factorial
    | tmp |
    tmp:= 1.
    2 to: self do: [ :i | tmp := tmp * i ]
]]]

${slide:title=Class definition|label=class definition}$

[[[
Object subclass: #Point
    instanceVariableNames: 'x y'
    classVariableNames: ''
    category: 'Graphics'
]]]

${slide:title=Method definition|label=classdefinition}$

- Normally defined in a browser or (by directly invoking the compiler)
- Methods are public
- By default return ==self==

[[[language=smalltalk
Node >> dist: aPoint 
	"Answer the distance between aPoint and the receiver."
	| dx dy |
	dx := aPoint x - x.
	dy := aPoint y - y.
	^ (dx * dx + (dy * dy)) sqrt
]]]


${slide:title=Instance Creation are Messages Too!|label=methoddefinition}$

- Messages sent to instance
[[[language=smalltalk
    '1', 'abc'
    1@2
]]] 
   
- Basic class creation messages are ==new== and ==new:== sent to a class
[[[language=smalltalk
     Monster new
]]]
- Class specific message creation (messages sent to classes)
[[[language=smalltalk
     Tomagoshi withHunger: 10
]]]

${slide:title=Conclusion|label=methoddefinition}$

- Compact syntax
- Few constructs but really expressive
- Support for Domain Specific Languages
- Mainly messages and closures