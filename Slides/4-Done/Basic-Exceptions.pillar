{
	"title":"Exception Overview",
	"author":"StÃ©phane Ducasse",
	"complement":"http://stephane.ducasse.free.fr/ stephane.ducasse@inria.fr"
}

${slide:title=Exception|label=exception}$

- Two important classes:
-- ==Error== and ==Notification==
- Really powerful
- Can be resumed, restarted, and signaled as new exception
- For more complete reference, read Deep into Pharo 


${slide:title=API overview|label=api}$

- Setting: ==on: Exception do: [ :ex| something ]==
- Raising: ==signal==
- ==defaultAction== is executed when an exception occurs

Convenient messages:

- ==ensure:==, ==ifCurtailed:==

${slide:title=Signaling an Exception}$

- To raise an exception: 
-- create an instance of exception
-- send it the messages ==signal== or ==signal: aMessage==

[[[language=smalltalk
    (AuthorNameRequest new initialAnswer: 'Stef') signal
    (Warning new messageText: 'Pay attention') signal
]]]

Usually classes propose a shortcut
[[[language=smalltalk
    OutOfMemory signal.
    Warning signal: 'description of the exception'
]]]

${slide:title=Catching Example}$

[[[language=smalltalk
    |x y|
    x := 7.
    y := 0.
    [ x / y ] 
        on: ZeroDivide
        do: [ :exception| Transcript show: exception description, cr.
             0 ]
]]]

${slide:title=Testing that an exception happens}$

- SUnit offers ==should:raise:== and ==shouldnt:raise:== to check occurrence of exceptions.

[[[language=smalltalk
    testNameOfMonth

        self assert: (Date nameOfMonth: 1) equals: #January.	
        self assert: (Date nameOfMonth: 12) equals: #December.

        self shouldnt: [ Date nameOfMonth: 2 ] raise: SubscriptOutOfBounds.
        self should: [ Date nameOfMonth: 0 ] raise: SubscriptOutOfBounds.
        self should: [ Date nameOfMonth: 13 ] raise: SubscriptOutOfBounds.
]]]

${slide:title=Kinds of Exceptions}$

- Error: all the Errors (subscript, message not understood, division by zero
- Halt 
- Notification: non fatal exceptions (deprecation, warning, timedout)
- UnhandledError: when an error occurs and that it is ''not'' trapped.

${slide:title=Exception are real objects}$

[[[language=smalltalk
ProtoObject >> doesNotUnderstand: aMessage

   ^ MessageNotUnderstood new 
        message: aMessage;
        receiver: self;
        signal
]]]	

${slide:title=Deprecation}$

To support API migration, Pharo uses deprecation.
When the deprecation setting is on, a warning is raised when a deprecated method is executed

[[[language=smalltalk
MenuItem >> title: aString
	"Add a title line at the top of this menu."
	self deprecated: 'Use method addTitle: instead' on: '29 september' in: #Pharo40. 
	self addTitle: aString
]]]

[[[language=smalltalk
deprecated: anExplanationString on: date in: version
    "Warn that the sending method has been deprecated"
    (Deprecation
        method: thisContext sender method
        explanation: anExplanationString
        on: date
        in: version) signal
]]]



${slide:title=ExceptionSet}$

Exception Sets
[[[language=smalltalk
    [ do some work ]
            on: ZeroDivide, Warning
            do: [ :ex | what you want ]
]]]

Or
[[[language=smalltalk
    | exceptionSets |
    exceptionSets := ExceptionSet with: ZeroDivide with: Warning.
    [do some work]
        on: exceptionSets
        do: [ :ex | what you want ]
]]]


${slide:title=A nice helper: ensure:}$

- How to ensure that an expression is executed is always executed (even if the program fails before)?
- Use ==ensure:==

[[[language=smalltalk
	spyOn: aBlock
		"Profile system activity during execution of aBlock."
		self startProfiling.
		aBlock ensure: [ self stopProfiling ]
]]]

${slide:title=Another nice helper ifCurtailed:}$

- How to ensure that an expression is executed is only if the program fails or returns?
- Use ==ifCurtailed:==

[[[language=smalltalk
	wait
		"Schedule this Delay, then wait on its semaphore. The current process will be suspended for the amount of time specified when this Delay was created."

		self schedule.
		[delaySemaphore wait] ifCurtailed:[self unschedule].
]]]


${slide:title=Exception Lookup}$

- Each process has its own exception environment: an ordered list of active handlers.
- Process starts with an empty list.
- ==[aaaa] on: Error do: [bbb]== adds ==Error,bbb== to the beginning of the list.
- When an exception is signaled, the system sends a message to the first handler. 
-- If the handler cannot handle the exception, the next one is asked.
-- If no handler can handle the exception, then the default action is performed.


${slide:title=Handling Exception}$

Within an handler ==[aaa] on: anExceptionClass do: anHandler==, we can:
- return an alternative result for the protected block by sending ==return:== aValue to the exception object;
- retry the protected block, by sending retry, or try a different block by sending ==retryUsing:==;
- resume the protected block at the failure point by sending ==resume== or ==resume:==;
- pass the caught exception to the enclosing handler by sending ==pass== or
- resignal a different exception by sending ==resignalAs:== to the exception.

${slide:title=Returning from an Exception}$

[[[language=smalltalk
[Notification signal. 'Value from protected block']
		on: Notification
		do: [:ex|ex return: 'Value from handler']
]]]

- We return a different string on normal or notification 


${slide:title=Resuming from Resumable Exception}$

- Warning, Notification and subclasses are resumable.


[[[language=smalltalk
[Notification signal. 'Value from protected block']
		on: Notification
		do: [:ex|ex resume: 'Value from handler']

> 'Value from protected Block'.
]]]

- ==Notification signal== raises an exception, 
- the exception is trapped
- then ==resume:== restores the context and the value returned normally as if the notification did not occur.


${slide:title=Summary}$

- Exceptions are powerful in Pharo. 
- Offer a simple API
-- raising: ==signal==
-- catching: ==on:do:==
-- ==ensure:== and ==ifCurtailed:==



