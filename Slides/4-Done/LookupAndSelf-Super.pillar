{
    "title":"Late Binding",
    "subtitle":"Understanding method lookup and self/super",
    "author":"StÃ©phane Ducasse and Damien Cassou",
    "complement":"http://stephane.ducasse.free.fr/ stephane.ducasse@inria.fr damien.cassou@inria.fr"
}

${slide:title=Goal}$

- Sending a message
- Dynamic binding/method lookup
- ==self==/==super== semantics

${slide:title=Message Sending}$

Sending a message means ''looking up'' the method to execute in the class of the receiver and ''executing'' it on the receiver with the arguments.

Sending a message is a two-step process:
# look up the method whose name matches the message selector;
# execute this method on the receiver with the arguments.

Let's present step 1 now.

${slide:title=Method Lookup}$

The lookup starts in the ''class'' of the ''receiver'' then:
-if the method is defined in the class, it is returned;
-otherwise the search continues in the superclasses;
-when there is no more superclass... (explained later :-))


${slide:title=Method Lookup}$

+>file://figures/LookupEssence.png|width=55+

${slide:title=Some Lookup Cases}$

+>file://figures/LookupExemple.png|width=70+


${slide:title=Method Lookup Starts in the Receiver Class}$

+>file://figures/LookupWithSelfInSuperclassMethod.png|width=50+

[[[
    A new foo
    > ...
    B new foo 
    > ...
]]]

${slide:title=Method Lookup Starts in the Receiver Class}$

+>file://figures/LookupWithSelfInSuperclassMethod.png|width=50+

[[[
    A new foo
    > 10
    B new foo 
    > 50
]]]

${slide:title=What is self/this?}$

Take 5 min and write the definition of ==self== (==this== in Java).

- Your definition should have two points:
-- What does ==self== represent?
-- How are the methods looked up when a message is sent to ==self==?

${slide:title=self/this}$

- ==self== represents the receiver of the message
- ==self== in Pharo, ==this== in Java, C\#
- the method lookup starts in the class of the receiver

${slide:title=self represents the receiver}$

+>file://figures/LookupWithSelfInSuperclassMethod.png|width=50+

[[[
    A new bar
    > ...
    B new bar
    > ...
]]]

${slide:title=self represents the receiver}$

+>file://figures/LookupWithSelfInSuperclassMethod.png|width=50+

[[[
    A new bar
    > 10
    B new bar
    > 50             <-- discussed on the next slide
]]]


${slide:title=self represents the receiver}$

${columns}$

${column:width=35}$

+>file://figures/LookupWithSelfInSuperclassMethod.png|width=100+

${column:width=65}$

[[[
    B new bar 
    > 50
]]]
#==aB bar==: no method ==bar== defined in ==B==
#look up in ==A== - the method ==bar== is found
#method ==bar== is executed on the receiver (==aB = B new==)
#==self== refers to ==aB==
#==foo== is sent to ==self==
#look up ==foo== in the receiver's class: ==B==!
#==foo== is found there and executed on ==aB==

${endColumns}$

${slide:title=self Always Represents the Receiver}$

+>file://figures/LookupWithSelfInSuperclassMethodThreeClasses.png|width=30+

[[[
    A new bar
    > ...
    B new bar 
    > ...
    C new bar
    > ... 
]]]

${slide:title=self Always Represents the Receiver}$

+>file://figures/LookupWithSelfInSuperclassMethodThreeClasses.png|width=30+

[[[
    A new bar
    > 10
    B new bar 
    > 10
    C new bar
    > 50
]]]

${slide:title=When No Method is Found}$

If no method is found in the hierarchy, a new message ==#doesNotUnderstand:== is sent to the receiver, with the initial message as parameter.

+>file://figures/LookupEssenceWithDoesNotUnderstand.png|width=30+


${slide:title=When No Method is Found}$

A new message ==#doesNotUnderstand:== is sent to the receiver, with the initial message as parameter.==doesNotUnderstand:== is looked up as a normal message.

+>file://figures/LookupEssenceWithDoesNotUnderstandFull.png|width=65+



${slide:title=Step by Step...}$

${columns}$

${column:width=50}$

- ==node1 coucou: #stef==
-# ==coucou:== is looked up in ==Node==
-# not defined in ==Node== -> lookup continues in ==Object==
-# not defined in ==Object== => system sends ==doesNotUnderstand:== to ==node1==
-# ==doesNotUnderstand:== is looked up in ==Node==
-# not defined in ==Node== -> lookup continues in ==Object==
-# ==Object>>doesNotUnderstand:== is found and executed

${column:width=50}$

+>file://figures/LookupEssenceWithDoesNotUnderstandFull.png|width=100+

${endColumns}$

${slide:title=doesNotUnderstand: is a Message}$

-==doesNotUnderstand:== is a message
-every class can customize handling of this error
-important hook for automatic delegation

${slide:title=doesNotUnderstand: and the Debugger}$

What happens when a message is not understood can be customized:

- the message ==doesNotUnderstand:== is looked up
- when no class redefines the message ==doesNotUnderstand:==
-- a ==MessageNotUnderstood== exception is raised
-- when there is no handler of that exception, the default is to open a debugger
- this behavior can be customized to hide/control/log errors

[[[language=smalltalk
SomeClass>>doSomething
  [ anObject nonExistingMethod ]
  on: MessageNotUnderstood
  do: [ Transcript show: 'Something went wrong with a message' ]
]]]

${slide:title=What is super?}$

Take 5 min and write the definition of super?

- Your definition should have two points:
-- What does it represent?
-- How the method are looked up when a message is sent to ==super==?


${slide:title=How do we access to an overriden method?}$

- You define a method with the same name that one in an upper class.
- You want to execute it in your subclass?
- Use ==super== instead of ==self==

[[[language=Smalltalk
    Workstation>>accept: aPacket
        (aPacket isAddressedTo: self)
            ifTrue: [ Transcript show: 'Accepted by the Workstation ', self name asString ]
            ifFalse: [ super accept: aPacket ]
]]]


${slide:title=Challenge yourself with super!}$

${columns}$

${column:width=50}$

+>file://figures/LookupWithSuperInSuperclassMethodThreeClasses.png|width=90+

${column:width=50}$

[[[
   	A new bar
    > ...
    B new bar 
    > ...
    C new bar
    > ...
]]]

${endColumns}$

${slide:title=Challenge yourself with super!}$

${columns}$

${column:width=50}$

+>file://figures/LookupWithSuperInSuperclassMethodThreeClasses.png|width=90+

${column:width=50}$

[[[
   	A new bar
    > 10
    B new bar 
    > 20
    C new bar
    > 100
]]]

${endColumns}$


${slide:title=Super changes the class where the lookup starts}$

${columns}$

${column:width=30}$

+>file://figures/LookupWithSuperInSuperclassMethodThreeClasses.png|width=100+

[[[
    C new bar
    > 100
]]]

${column:width=70}$

- ==bar== is sent to ==aC== (an instance of C): ==bar== is looked up in C, not found, look in ==B==
- ==bar== is found in class B, and applied to the receiver ==aC==. 
- ==bar== is sent to ==super==, 
- ==super== is the receiver (aC), but lookup starts above class ==B==
- ==bar== is found in class ==A== and it is applied to the receiver ==aC==.
- ==foo== is sent to ==self==: ==self== represents the receiver: ==aC==
- ==foo== is found in class ==C== and applied to ==aC==, it returns 50.

${endColumns}$

${slide:title=Super?}$

- ==super== refers to the receiver of the message (like ==self==. Yes!)
- The method lookup starts in the superclass of ...?



${slide:title=Super starts lookup in superclass of the class using it}$

- ==super== refers to the receiver of the message (like ==self==. Yes!)
- The method lookup starts in the superclass of the class containing the super expression.

${slide:title=Super is static / self is dynamic}$

- There is no reference to the receiver in the method lookup of a ==super== invocation!

${slide:title=self is dynamic|label=selfdynamic}$

${columns}$

${column:width=50}$

- When we read the body of method ==bar==, there is no way that we know which method ==foo== will be executed.
- New instances of different classes can be created and the message ==bar== sent to them.
- ==self== acts as a hook. Code of subclasses can be injected into ==self== sends.

${column:width=50}$

+>file://figures/SelfIsDynamic1.png|width=60+

${endColumns}$

${slide:title=super is static|label=super}$

${columns}$

${column:width=50}$

+>file://figures/SuperIsStatic.png|width=50+

${column:width=50}$

- At compilation-time, just reading the code we know that we should look above the class containing the ""method"" using ==super==.

${endColumns}$

${slide:title=Yes even some books got it wrong}$

- Wrong definition: super looks for the method in the superclass of the class of the ""receiver"".
- Wrong!
- It would loop forever!
- ==aC foo== loops, because ==super== points to ==aC== and the superclass of the class of the receiver is B.

+>file://figures/LookupWithWrongDefinition.png|width=45+




${slide:title=What you should know}$

- ==self== ''always'' represents the receiver
- the method lookup maps a message to a method
- the method lookup starts in the class of the receiver...
- ...and goes up in the hierarchy
- ==super== is the receiver, lookup starts is superclass of the method using the expression.
- self sends act as a hook. Code of subclasses may be invoked.







