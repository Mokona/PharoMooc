{
	"title":"A glimpse at essential collections",
	"subtitle":"",
	"author":"StÃ©phane Ducasse",
	"complement":"http://stephane.ducasse.free.fr/ stephane.ducasse@inria.fr"
}

${slide:title=Collections In a Nutshell|label=arrays}$

- Pharo has a rich hierarchy of collection
- Common API: ==size==, ==do:==, ==select:==, ==includes:==, ==collect:==...
- Element 1 is at index 1
- Can contain any objects
- Most common ones:
-- ==Set== (no duplicates)
-- ==OrderedCollection== (dynamically growing)
-- ==Array== (fixed size, direct access)
-- ==Dictionary== (key-based)

${slide:title=Essential Collection Inheritance Hierarchy In a Nutshell|label=arrays}$

+>file://figures/CollectionHierarchyForIntroChapter.png|width=80+


${slide:title=Common API|label=arrays}$

- Most iterators works on all collections

#creation ==with: anElement==, ==with:with:==, ==withAll: aCollection==
#accessing: ==size==, ==capacity==, ==at: anIndex==, ==at: anIndex put: anElement==
#testing ==isEmpty==, ==includes: anElement==, ==contains: aBlock==, ==occurrencesOf: anElement==
#adding ==add: anElement==, ==addAll: aCollection==
#removing ==remove: anElement==, ==remove: anElement ifAbsent: aBlock==, ==removeAll: aCollection==
#enumerating ==do: aBlock==, ==collect: aBlock==, ==select: aBlock==, ==reject: aBlock==, ==detect: aBlock==, ...
#converting ==asBag==, ==asSet==, ==asOrderedCollection==, ==asSortedCollection==, ==asArray==

${slide:title=Creating variable size objects|label=arrays}$

- Message ==new== instantiates one object
- Message ==new: size== creates an object specifying its size

[[[language=smalltalk
    Array new: 4
    > #(nil nil nil nil)

    Array new: 2
    > #(nil nil)
	
    (OrderedCollection new: 1000) capacity
    > 1000
	
    OrderedCollection withAll: #(7 3 13)
    > an OrderedCollection(7 3 13)
	
    Set withAll: #(7 3 13)
    a Set( 7 3 13)
]]]

${slide:title=Creation variants with default value|label=arrays}$

[[[language=smalltalk
    OrderedCollection new: 5 withAll: 'a' 
    > an OrderedCollection('a' 'a' 'a' 'a' 'a')
]]]

${slide:title=Array|label=arrays}$

- Fixed size collection
- Direct access: ==at:==/==at:put:==
- Has literal syntax: ==#( ... )== 

Returning the size of the collection
[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') size
    > 3
]]]

Accessing the second element of the receiver
[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') at: 2
    > 'hates'
]]]

[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') at: 55
    > Error
]]]


${slide:title=Literal Arrays|label=arrays}$

[[[language=smalltalk
    #(45 38 1300 8) class
    > Array
]]]

- Literal arrays are created by the parser: when the expression is read, i.e. when the method is compiled, not the method is executed.

${slide:title=Literals Arrays|label=arrays}$

Literal arrays are equivalent to a dynamic version.

- A literal array
[[[language=smalltalk
    #(45 38 1300 8) 
    > #(45 38 1300 8) 
]]]
- A dynamic array
[[[language=smalltalk
    Array with: 45 with: 38 with: 1300 with: 8
    > #(45 38 1300 8) 
]]]

- =={  .  . }== is syntactic sugar to create dynamic arrays

[[[language=smalltalk
    > Array with: 45 with: 38 with: 1300 with: 8
    > #(45 38 1300 8)
    > { 45 . 38 . 1300 . 8 } 
]]]

${slide:title=Literals vs. Dynamic Arrays|label=arrays}$

There is no message executed when a literal array is created. 
[[[language=smalltalk
    #(45 + 38 1300 8) 
    > #( 45 #+ 38 1300 8)
	
    #(45 + 38 1300 8) size
    > 5
]]]

Dynamic arrays are created during the program execution.
[[[language=smalltalk
    Array with: 45 + 38 with: 1300 with: 8
    > #( 83 . 1300 . 8)

    { 45 + 38 . 1300 . 8 }
    > #( 83 . 1300 . 8)
]]]

${slide:title=First element starts at 1 |label=arrays}$

[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') at: 2
    > 'hates'
	
    #('Calvin' 'hates' 'Suzie') asOrderedCollection  at: 2 
    > 'hates'
]]]

${slide:title= at: to access, at:put: to set|label=arrays}$

[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') at: 2 put: 'loves'
    > #('Calvin' 'loves' 'Suzie')
]]]

${slide:title=Variants|label=arrays}$

- An array of symbols:
[[[language=smalltalk
    #(#calvin #hobbes #suzie)	
    > #(#calvin #hobbes #suzie)	
    #(calvin hobbes suzie)
    > #(#calvin #hobbes #suzie)
]]]

- An array of strings:
[[[language=smalltalk
    #('calvin' 'hobbes' 'suzie')
    > #('calvin' 'hobbes' 'suzie')
]]]

${slide:title=Collection can contain heterogenous objects|label=arrays}$

- Heterogenous
[[[language=smalltalk
    #('calvin' (1 2 3))
    > #('calvin' #(1 2 3))
	
    #('lulu' 1.22 1)
    > #('lulu' 1.22 1)
]]]

${slide:title=Byte Arrays |label=arrays}$
- Fixed size arrays.
- Elements are integers between 0 and 255.
- Has a special syntax: ==#[ 1 2 255 ]==

${slide:title=OrderedCollection|label=arrays}$

- Growing size
- ==add:==, ==remove:==

[[[language=smalltalk
    | ordCol |
    ordCol := OrderedCollection new.
    ordCol add: 'Reef'; add: 'Pharo'; addFirst: 'Pharo'.
    ordCol 
    > an OrderedCollection('Pharo' 'Reef' 'Pharo')
	ordCol add: 'Seaside'.
	ordCol
	> an OrderedCollection('Pharo' 'Reef' 'Pharo' 'Seaside')
]]]

[[[language=smalltalk
    #('Pharo' 'Reef' 'Pharo' 'Pharo') asOrderedCollection
    > an OrderedCollection('Pharo' 'Reef' 'Pharo' 'Pharo')
]]]

${slide:title=Set|label=set}$

- No duplicates
- Growing size
- ==add:==, ==remove:==

[[[language=smalltalk
    #('Pharo' 'Reef' 'Pharo' 'Pharo') asSet
    >  a Set('Pharo' 'Reef')
]]]

${slide:title=Summary|label=set}$

- Easy to use collections.
- Common vocabulary.
- Simple conversion between them.

