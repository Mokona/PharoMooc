{
	"title":"An overview of essential collections",
	"subtitle":"",
	"author":"StÃ©phane Ducasse",
	"complement":"http://stephane.ducasse.free.fr/ stephane.ducasse@inria.fr"
}

${slide:title=Collections In a Nutshell|label=arrays}$

- Pharo has a rich hierarchy of collection
- Common API: ==size==, ==do:==, ==select:==, ==includes:==, ==collect:==...
- First element is at index ==1==
- Can contain any object
- Most common collections:
-- ==OrderedCollection== (dynamically growing)
-- ==Array== (fixed size, direct access)
-- ==Set== (no duplicates)
-- ==Dictionary== (key-based, ''aka.'' maps)

${slide:title=Essential Collection Inheritance Hierarchy In a Nutshell}$

+>file://figures/CollectionHierarchyForIntroChapter.png|width=80+


${slide:title=Common API|label=arrays}$

- Most iterators work on all collections

#creation: ==with: anElement==, ==with:with:==, ==withAll: aCollection==
#accessing: ==size==, ==capacity==, ==at: anIndex==, ==at: anIndex put: anElement==
#testing: ==isEmpty==, ==includes: anElement==, ==contains: aBlock==, ==occurrencesOf: anElement==
#adding: ==add: anElement==, ==addAll: aCollection==
#removing: ==remove: anElement==, ==remove: anElement ifAbsent: aBlock==, ==removeAll: aCollection==
#enumerating: ==do: aBlock==, ==collect: aBlock==, ==select: aBlock==, ==reject: aBlock==, ==detect: aBlock==, ...
#converting: ==asBag==, ==asSet==, ==asOrderedCollection==, ==asSortedCollection==, ==asArray==

${slide:title=Creating variable size objects}$

- Message ==new== instantiates one object
- Message ==new: size== creates an object specifying its size

[[[language=smalltalk
    Array new: 4
    > #(nil nil nil nil)

    Array new: 2
    > #(nil nil)
	
    (OrderedCollection new: 1000) capacity
    > 1000
	
    OrderedCollection withAll: #(7 3 13)
    > an OrderedCollection(7 3 13)
	
    Set withAll: #(7 3 13)
    a Set( 7 3 13)
]]]

${slide:title=Creation variants with default value|label=arrays}$

[[[language=smalltalk
    OrderedCollection new: 5 withAll: 'a' 
    > an OrderedCollection('a' 'a' 'a' 'a' 'a')
]]]

${slide:title=Arrays}$

- Fixed size collection
- Direct access: ==at:== and ==at:put:==
- Has literal syntax: ==#( ... )== 
- Can also be created using ==new:== 

[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') size
    > 3
]]]

is equivalent to 

[[[language=smalltalk
    (Array new 
       at: 1 put: 'Calvin'; 
       at: 2 put: 'hates'; 
	   at: 3 put: 'Suzie') size
    > 3
]]]

${slide:title=Accessing elements}$

Returning the size of the collection
[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') size
    > 3
]]]

Accessing the second element of the receiver using ==at: anIndex==
[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') at: 2
    > 'hates'
]]]

[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') at: 55
    > Error
]]]

${slide:title=Changing elements}$

Use the message ==at: anIndex put: anObject== 

Accessing the second element of the receiver
[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') at: 2 put: 'loves'
]]]


${slide:title=Literal Arrays}$

[[[language=smalltalk
    #(45 38 1300 8) class
    > Array
]]]

- Literal arrays are created by the parser: when the expression is read, i.e. when the method is compiled, not the method is executed.


[[[language=smalltalk
    #(45 'milou' 1300 true #tintin)
    > #(45 'milou' 1300 true #tintin)
]]]

- Literal arrays contains objects that have a textual (literal) representation: numbers, strings, nil, symbols


${slide:title=Literals Arrays are Array instances}$

Literal arrays are equivalent to a dynamic version.

- A literal array
[[[language=smalltalk
    #(45 38 1300 8) 
    > #(45 38 'milou' 8) 
]]]
- An array
[[[language=smalltalk
    Array with: 45 with: 38 with: 'milou' with: 8
    > #(45 38 'milou' 8) 
]]]


${slide:title=Array short syntax}$

Defining array is tedious 
[[[language=smalltalk
    | array | 
    array := (Array new: 2). 
    array 
         at: 1 put: (Point x: 10 y: 20); 
         at: 2 put: (Point x: 10 y: 20).
     array
]]]

- =={ element . element  . element }== is syntactic sugar to create arrays

[[[language=smalltalk
    {(10@20) . (10@20)}
    {Point x: 10 y: 20 . Point x: 10 y: 20}
]]]

${slide:title= Slide title help}$

\{\} vs \#()

Pay attention: =={}== executes expressions while #() not.
[[[
    {(10@20) . (10@20)} size 
    > 2
    {(10@20) . (10@20)}
    > {(10@20) . (10@20)}

    #((10@20) . (10@20)) size 
    > 3
    #((10@20) . (10@20))
    > #(#(10 #@ 20) #'.' #(10 #@ 20))
    #((10@20) . (10@20)) first class
	> Array
]]]



${slide:title= Slide title help please}$

\{\} vs \#()

There is no message executed when a literal array is created. 
[[[language=smalltalk
    #(45 + 38 1300 8) 
    > #( 45 #+ 38 1300 8)
	
    #(45 + 38 1300 8) size
    > 5
]]]

Arrays created with message sends are created during program execution.
[[[language=smalltalk
    Array with: 45 + 38 with: 1300 with: 8
    > #( 83 . 1300 . 8)

    { 45 + 38 . 1300 . 8 }
    > #( 83 . 1300 . 8)
]]]

${slide:title=First element starts at 1 |label=arrays}$

[[[language=smalltalk
    #('Calvin' 'hates' 'Suzie') at: 2
    > 'hates'
	
    #('Calvin' 'hates' 'Suzie') asOrderedCollection  at: 2 
    > 'hates'
]]]



${slide:title=Variants|label=arrays}$

- An array of symbols:
[[[language=smalltalk
    #(#calvin #hobbes #suzie)	
    > #(#calvin #hobbes #suzie)	
    #(calvin hobbes suzie)
    > #(#calvin #hobbes #suzie)
]]]

- An array of strings:
[[[language=smalltalk
    #('calvin' 'hobbes' 'suzie')
    > #('calvin' 'hobbes' 'suzie')
]]]

${slide:title=Collection can contain heterogenous objects|label=arrays}$

- Heterogenous
[[[language=smalltalk
    #('calvin' (1 2 3))
    > #('calvin' #(1 2 3))
	
    #('lulu' 1.22 1)
    > #('lulu' 1.22 1)
]]]

${slide:title=Byte Arrays |label=arrays}$
- Fixed size arrays.
- Elements are integers between 0 and 255.
- Has a special syntax: ==#[ 1 2 255 ]==

${slide:title=OrderedCollection|label=arrays}$

- Growing size
- ==add:==, ==remove:==

[[[language=smalltalk
    | ordCol |
    ordCol := OrderedCollection new.
    ordCol add: 'Reef'; add: 'Pharo'; addFirst: 'Pharo'.
    ordCol 
    > an OrderedCollection('Pharo' 'Reef' 'Pharo')
	ordCol add: 'Seaside'.
	ordCol
	> an OrderedCollection('Pharo' 'Reef' 'Pharo' 'Seaside')
]]]

[[[language=smalltalk
    #('Pharo' 'Reef' 'Pharo' 'Pharo') asOrderedCollection
    > an OrderedCollection('Pharo' 'Reef' 'Pharo' 'Pharo')
]]]

${slide:title=Set|label=set}$

- No duplicates
- Growing size
- ==add:==, ==remove:==

[[[language=smalltalk
    #('Pharo' 'Reef' 'Pharo' 'Pharo') asSet
    >  a Set('Pharo' 'Reef')
]]]


${slide:title=Dictionary|label=set}$

- Key/values
- Growing size
- Accessing ==at:==, ==at:ifAbsent:==
- Changing/adding ==at:put:==, ==at:ifAbsentPut:== 
- iterating: ==do:==, ==keysDo:==, ==keysAndValuesDo:==

${slide:title=Dictionary creation|label=set}$

[[[language=smalltalk
	| days |
	days := Dictionary new. 
	days 	
		at: #January put: 31;
		at: #February put: 28;
		at: #March put: 31.	
]]]

[[[language=smalltalk
	days at: #January 
	> 31 

	days at: #NoMonth
	> KeyNotFound Error

	days at: #NoMonth ifAbsent: [0]
	> 0 
]]]

${slide:title=Dictionary iteration}$

[[[language=smalltalk
days do: [ :each | Transcript show: each ;cr ] 
]]]

prints the days

[[[language=smalltalk
Dictionary >> do: aBlock

		^self valuesDo: aBlock
]]]

[[[language=smalltalk
days keysAndValuesDo: 
	[ :k :v | Transcript show: k asString, ' has ',  v printString, ' days' ; cr ] 
]]]

shows: 
[[[language=smalltalk
	January has 31 days
	February has 28 days
	March has 31 days
]]]



${slide:title=Summary|label=set}$

- Easy to use collections.
- Common vocabulary.
- Simple conversion between them.

