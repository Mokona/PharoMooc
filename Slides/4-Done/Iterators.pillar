{
    "title":"Iterators"
}

${slide:title=Objectives|label=objectives}$

- Understand iterators
- Offer an overview

${slide:title=Pharo code is Compact!}$

[[[language=Java
ArrayList<String> strings = new ArrayList<String>();
   for(Person person: persons)
            strings.add(person.name());
]]]

[[[language=smalltalk
strings := persons collect: [ :person | person name ]
]]]

- Yes in Java 8.0 it will be finally simpler.
- But it is like that in Pharo since day one!
- Iterators are deep into the core of the language.


${slide:title= A first iterator: collect:}$

- ==collect:== applies the block to each element and returns a collection (of the same kind than the receiver) with the results

[[[language=smalltalk
    #(2 -3 4 -35 4) collect: [ :each | each abs ]
    > #(2 3 4 35 4)
]]]

- ==collect:== sends the message ==abs== (absolute) to each element of the receiver 
- and returns the resulting collection.
- What we see is that we ask the collection to do something for us.

${slide:title=Another collect: example}$

- We want to know if each elements is odd or even.

[[[language=smalltalk
    #(16 11 68 19) collect: [ :i | i odd ]
]]]

[[[language=smalltalk
    >  #(false true false true)
]]]


${slide:title=Choose your camp!}$

[[[language=smalltalk
    #(16 11 68 19) collect: [ :i | i odd ]
]]]

- We can also do it that way!
[[[language=smalltalk
    | result |
    aCol :=  #(16 11 68 19).
    result := aCol species new: aCol size.
    1 to: aCollection size do:
        [ :each | result at: each put: (aCol at: each) odd ].
    ^ result
]]]

- Here we copied the definition of ==collect:==, to show how we could  expressed the same behavior but this is error prone, verbose and tedious.






${slide:title=Part of the collection hierarchy}$

- Iterators work polymorphically on the entire collection hierarchy.

+Part of the Collection hierarchy.>file://figures/CollectionHierarchy.png|width=60+
Part of the Collection hierarchy.


${slide:title=Think objects!}$

- With iterators we ask the collection to iterate on itself.
- As a client we do not have to know the internal details of the collection.
- Each collection can implement differently the iterator.


${slide:title=Basic Iterators Overview}$


- ==do:== (iterate)
- ==collect:== (iterate and collect results)
- ==select:== (select matching elements)
- ==reject:== (reject matching elements)
- ==detect:== (get first element matching)
- ==detect:ifNone:== (get first element matching or a default value)
- ==includes:== (test inclusion)
- and a lot more...


${slide:title=do: an action on each element}$

- Iterates on each elements
- Applies the block on each elements

[[[language=smalltalk
    #(16 11 68 19) do: [ :each | Transcript show: each ; cr ]
]]]
- Here we print each elements and insert a carriage return.

+Results of do: >file://figures/Iterators-Transcript.png|width=50|label=Iterators-Transcript+


${slide:title=select: elements matching a criteria}$

- Select some elements

[[[language=smalltalk
    #(16 11 68 19) select: [ :element | element odd ]
]]]


${slide:title=select: elements matching a criteria}$

- Select some elements

[[[language=smalltalk
    #(16 11 68 19) select: [ :i | i odd ]
]]]

[[[language=smalltalk
    > #(11 19)
]]]

${slide:title=With unary messages, no block needed}$

When a block expects a single argument, we can pass an unary message selector
[[[language=smalltalk
    #(16 11 68 19) select: [ :i | i odd ]
]]]

is equivalent to

[[[language=smalltalk
    #(16 11 68 19) select: #odd
]]]


${slide:title=reject: elements matching a criteria}$

- Filter some elements

[[[language=smalltalk
    #(16 11 68 19) reject:  [ :i | i odd ]
]]]


${slide:title=reject: elements matching a criteria}$

- Filter some elements

[[[language=smalltalk
    #(16 11 68 19) reject:  [ :i | i odd ]
]]]

[[[language=smalltalk
    > #(16 68)
]]]


${slide:title=detect: the first elements that...}$

- First element that matches

[[[language=smalltalk
    #(16 11 68 19) detect:  [ :i | i odd ]
]]]

${slide:title=detect: the first elements that...}$

- First element that matches

[[[language=smalltalk
    #(16 11 68 19) detect:  [ :i | i odd ]
]]]

[[[language=smalltalk
    > 11
]]]



${slide:title=detect:ifNone:}$

- First element that matches else return a value

[[[language=smalltalk
    #(16 12 68 20) detect:  [ :i | i odd ] ifNone: [ 0 ]
]]]



${slide:title=detect:ifNone:}$

- First element that matches else return a value

[[[language=smalltalk
    #(16 12 68 20) detect:  [ :i | i odd ] ifNone: [ 0 ]
]]]

[[[language=smalltalk
    > 0
]]]

${slide:title=Some other iterators}$

- ==anySatisfy:== (tests if one object is satisfying the criteria)
- ==allSatisfy:== (tests if all objects are satisfying the criteria)
- ==reverseDo:== (do an action on the collection starting from the end)
- ==doWithIndex:== (do an action with the element and its index)
- ==pairsDo:== (evaluate aBlock with my elements taken two at a time.)
- ==permutationsDo:==

${slide:title=Exercises}$

Propose some expressions to illustrate ther uses of 
- ==anySatisfy:== (tests if one object is satisfying the criteria)
- ==allSatisfy:== (tests if all objects are satisfying the criteria)
- ==reverseDo:== (do an action on the collection starting from the end)
- ==doWithIndex:== (do an action with the element and its index)
- ==pairsDo:== (evaluate aBlock with my elements taken two at a time.)
- ==permutationsDo:==

${slide:title=Exciting ones}$

- How to produce?
[[[language=smalltalk
    #('a' 'b' 'c') message
    > 'a, b, c'

    #('a') message
    > 'a'
	
    #() message
    > ''
]]]

]]]



${slide:title=Exciting ones}$

- How to produce?
[[[language=smalltalk
    #('a' 'b' 'c') message
    > 'a, b, c'

    #('a') message
    > 'a'
	
    #() message
    > ''
]]]

- Use ==doSeparatedBy:==

[[[language=smalltalk
    String streamContents: [ :s |
                #('a' 'b' 'c')
                    do: [ :each | s << each ]
                    separatedBy: [ s << ', ']
                ]
]]]





${slide:title=Iterating two structures}$

[[[language=smalltalk
#(1 2 3)
    with:  #(10 20 30)
    do: [ :x :y | Transcript show: (y * x) ; cr ]
]]]

+Results of with:do: >file://figures/Iterator-WithDo-Transcript.png|width=50|label=Iterator-WithDo-Transcript+

- ==with:do:== requires two structures of the same length.

${slide:title=Grouping elements}$

- ==groupedBy:==

[[[language=smalltalk
    #(1 2 3 4 5 6 7 ) groupedBy: #even
]]]

[[[language=smalltalk
    a PluggableDictionary(false->#(1 3 5 7) true->#(2 4 6) )
]]]


${slide:title=Flattening results}$

- How to remove one level of nesting in a collection?
- Use ==flatCollect:==
[[[language=smalltalk
    #( #(1 2) #(3) #(4) #(5 #(6 7 3))) collect: [ :each | each ]

    > #(#(1 2) #(3) #(4) #(5 #(6 7 3)))
]]]

[[[language=smalltalk
    #( #(1 2) #(3) #(4) #(5 #(6 7 3))) flatCollect: [ :each | each ]

    > #(1 2 3 4 5 #(6 7 3))
]]]

${slide:title=Opening the box}$

- You can learn and discover the system.
- You can define your own.
- How ==do:== is implemented?
[[[language=smalltalk
SequenceableCollection>>do: aBlock
    "Evaluate aBlock with each of the receiver's elements as the argument."

    1 to: self size do: [:i | aBlock value: (self at: i)]
]]]

${slide:title=Analysis}$

- Iterators are really powerful because they support polymorphic code.
- All the collections support them.
- New ones are defined.
- Missing controlled navigation as in the Iterator design pattern.

${slide:title=Summary}$
- Iterators are your best friends
- Simple and powerful
- Enforce encapsulation of collections and containers