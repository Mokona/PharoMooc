{
    "title":"Avoid Null Checks",
    "subtitle":"",
    "author":"StÃ©phane Ducasse and Damien Cassou",
    "complement":"http://stephane.ducasse.free.fr/ stephane.ducasse@inria.fr"
}

${slide:title=The Pitch}$

- Avoid null checks
- This goes against "Tell, do not ask"
- Less checks, simpler logic, just send messages

+.>file://figures/antifIfCampaign.png|width=60+

${slide:title=First, avoid to return nil}$

- Do not force your clients to have to check
- Do not return nil AND another value
- Not a collection and may be nil

${slide:title=First, avoid to return nil}$

- Return polymorphic objects!
- Return collections and empty "collections"
- Not a collection and may be nil

${slide:title=First, avoid to return nil}$

- Avoid error codes :)
- If you should specify an exceptional behavior use an exception.

[[[
    [...] on: Error do:[...] or
    [ ... ] on: FileStreamException do: [ ... ] or
    [ ... ] on: FileDoesNotExistException do: [ ... ]
]]]


${slide:title=Example}$

[[[language=smalltalk
Inferencer >> getRulesFor: aFact
    ^ self computeRulesFor: aFact ifAbsent: [ nil ].
]]]

- It looks really suspicious! We may return ==nil==

[[[language=smalltalk
Inferencer >> computeRulesFor: aFact ifAbsent: aBlock
    self noRule ifTrue: [ ^ aBlock value ]
    ^ OrderedCollection with: self rules.
]]]

- ==getRulesFor:== return either a collection or nil! 
- Here you force "all" the clients of ==getRulesFor:== to check for ==nil== values!

${slide:title=Solution: return polymorphic objects}$

[[[language=smalltalk
Inferencer >> getRulesFor: aFact
    ^ self computeRulesFor: aFact ifAbsent: [#()].
]]]

- Your clients can just iterate and manipulate the returned value:

-- ==(self getRulesForFact: 'a') do: [:each | ...]==


${slide:title=Second, initialize your object state}$


[[[language=smalltalk
    Archive >> initialize
         super initialize.
         members := OrderedCollection new.
]]]

${slide:title=Second, initialize your object state}$

You can also use lazy initialization if necessary

[[[language=smalltalk
    FreeTypeFont >> descent
        ^ cachedDescent ifNil: [ 
              cachedDescent := (self face descender * self pixelSize // 
                                                          self face unitsPerEm) negated ]
]]]

- Do not forget to systematically use accessors.

${slide:title=Sometimes you have to check ...}$

- Sometimes you have to check before doing some action.
- If you can, turn the default case into an object (NullObject)

[[[language=smalltalk
    ToolPalette >> nextAction
        self selectedTool ifNotNil: [:t | t attachHandles]

    ToolPalette >> previousAction
        self selectedTool ifNotNil: [:t | t dettachHandles]
]]]

${slide:title=Third, use NullObject}$

- A null object proposes a polymorphic API and embeds default actions/values

- Woolf, Bobby (1998). "Null Object". In Pattern Languages of Program Design 3. Addison-Wesley.


${slide:title=Third, use NullObject}$

[[[language=smalltalk
    NoTool >> attachHandles
        ^ self
]]]

[[[language=smalltalk
    NoTool >> detachHandles
        ^ self
]]]

[[[language=smalltalk
    ToolPalette >> initialize
        self selectedTool: NoTool new
]]]

[[[language=smalltalk
    ToolPalette >> nextAction
        self selectedTool attachHandles
]]]

[[[language=smalltalk
    ToolPalette >> previousAction
        self selectedTool detachHandles
]]]


${slide:title=Conclusion}$
- Messages act as a dispatcher
- Avoid conditionals
- Return polymorphic objects
- If you can define, create objects that represent default behavior
- When you can avoid it, avoid returning ==nil==
- Initialize your variables


