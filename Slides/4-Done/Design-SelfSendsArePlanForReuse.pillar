{
    "title":"Message sends are plans for reuse",
    "author":"StÃ©phane Ducasse and Damien Cassou",
    "complement":"http://stephane.ducasse.free.fr/ stephane.ducasse@inria.fr"
}

${slide:title=Remember...}$

- Message passing is a choice operator
- Class hierarchies define choices
- ==self== always represents the receiver and method lookup starts in the class of the receiver

+One single class vs. a nice hierarchy.>file://figures/Design-FatVsDispatch.png|width=60+

${slide:title=Pitch}$

- Superclass code can be reused by subclasses 
- Sending messages in a superclass define places where subclass code can be injected.

${slide:title=A first example}$

[[[language=smalltalk
    Node >> setWindowWithRatioForDisplay
        | averageRatio defaultNodeSize |
        averageRatio := 55.
        defaultNodeSize := mainCoordinate /maximiseViewRatio.
        self window add:
            (UINode new with: (bandWidth * averageRatio / defaultWindowSize).
        previousNodeSize := defaultNodeSize.
]]]

- What if we want to change the ==defaultNodeSize== definition in our subclass?


${slide:title=A not that good solution}$
- What if we cannot modify the code of ==Node== (developed by another company)?

- Duplicate the code in our subclass

[[[language=smalltalk
    OurSpecificNode >> setWindowWithRatioForDisplay
        | averageRatio defaultNodeSize |
        averageRatio := 55.
        defaultNodeSize := (mainCoordinate /maximiseViewRatio) + 10.
        self window add:
            (UINode new with: (bandWidth * averageRatio / defaultWindowSize).
        previousNodeSize := defaultNodeSize.
]]]

- Note that if ==setWindowWithRatioForDisplay== uses private attributes (Java like languages), copying the code in subclass will not work.
- Duplication is not a good practice:
-- copy bugs,
-- fragile when original code will change,
-- burden on us to keep the system running. 

${slide:title=Solution}$

${columns}$

${column:width=50}$

- Define small methods
- Send messages to invoke such methods
- Let subclasses customize such methods

${column:width=50}$

+>file://figures/SelfIsDynamic.png|width=50+

${endColumns}$



${slide:title=Good design in the first place}$

[[[language=smalltalk
    Node >> setWindowWithRatioForDisplay
        | averageRatio defaultNodeSize |
        averageRatio := 55.
        defaultNodeSize := self ratio.
        self window add:
            (UINode new with: (bandWidth * averageRatio / defaultWindowSize).
        previousNodeSize := defaultNodeSize.
]]]
[[[language=smalltalk        
    Node >> ratio
        ^ mainCoordinate /maximiseViewRatio    
]]]


${slide:title=Subclasses reuse superclass logic}$

Now a subclass can only express the delta and reuse the superclass logic
[[[language=smalltalk    
    Node subclass: OurSpecificNode 
       ...
]]]


[[[language=smalltalk    
    OurSpecificNode >> ratio
         ^ super ratio + 10
]]]

${slide:title=Many small messages}$

- Newbies often complain that there are too many small methods
- This is a good property

[[[language=smalltalk
    Node >> uiNode
        ^ (UINode new with: (bandWidth * averageRatio / defaultWindowSize).
]]]

[[[language=smalltalk
    Node >> setWindowWithRatioForDisplay
        | defaultNodeSize |
        self averageRatio: 55.
        defaultNodeSize := self ratio.
        self window add: self uiNode
]]]

${slide:title=Do not hardcode class use}$

[[[language=smalltalk
    Node >> uiNode
        ^ (UINode new with: (bandWidth * averageRatio / defaultWindowSize).
]]]

${slide:title=Define method returning classes}$

[[[language=smalltalk
    Node >> uiNode
        ^ (self uiNodeClass new with: (bandWidth * averageRatio / defaultWindowSize).
]]]

[[[language=smalltalk		
     Node >> uiNodeClass
        ^ UINodeClass
]]]

${slide:title=From the exercise}$

To support 
[[[
	(DiceHandle new add: (Dice faces: 4); add: (Dice faces: 4); yourself) + (DiceHandle new add: (Dice faces: 6); yourself)
]]]

We define ==\+== as 

[[[smalltalk=language
DiceHandle>>+ aDiceHandle
    | handle |
    handle := DiceHandle new.
    self dice do: [ :each | handle addDice: each ]. 
    aDiceHandle dice do: [ :each | handle addDice: each ]. 
    ^ handle
]]]

${slide:title=Now we create a new subclass}$
[[[smalltalk=language
DiceHandle subclass: MyDiceHandle
    ....
]]]

[[[smalltalk=language
	(MyDiceHandle new add: (Dice faces: 4); add: (Dice faces: 4); yourself) + (MyDiceHandle new add: (Dice faces: 6); yourself)
]]]

- We get a ==DiceHandle== instance back and not a ==MyDiceHandle== instance!!!

${slide:title=Solution 1: Creating a Hook}$

[[[smalltalk=language
DiceHandle >> + aDiceHandle
	| handle |
	handle := self handleClass new.
	self dice do: [ :each | handle addDice: each ]. 
	aDiceHandle dice do: [ :each | handle addDice: each ]. 
	^ handle
]]]

[[[smalltalk=language
DiceHandle >> handleClass
	^ DiceHandle
]]] 


A subclass may redefine ==handleClass== 

[[[smalltalk=language
MyDiceHandle >> handleClass
	^ MyDiceHandle
]]] 



${slide:title=Solution 1: Creating a Hook}$

[[[smalltalk=language
DiceHandle >> + aDiceHandle
	| handle |
	handle := self handleClass new.
	self dice do: [ :each | handle addDice: each ]. 
	aDiceHandle dice do: [ :each | handle addDice: each ]. 
	^ handle
]]]

[[[smalltalk=language
DiceHandle >> handleClass
	^ DiceHandle
]]] 

A subclass may redefine ==handleClass== 

[[[smalltalk=language
MyDiceHandle >> handleClass
	^ MyDiceHandle
]]] 

[[[smalltalk=language
	(MyDiceHandle new add: (Dice faces: 4); add: (Dice faces: 4); yourself) + (MyDiceHandle new add: (Dice faces: 6); yourself)
]]]

We will get an instance of the subclass.

${slide:title=But we can do better!}$

In each subclass  we should redefine the hook method  ==handleClass==


${slide:title=Solution 2}$

[[[smalltalk=language
DiceHandle>>+ aDiceHandle
	| handle |
	handle := self class new.
	self dice do: [ :each | handle addDice: each ]. 
	aDiceHandle dice do: [ :each | handle addDice: each ]. 
	^ handle
]]]

-  ==self class== always returns the class of the receiver
- We get instances of the same kind of the receiver 

${slide:title=Solution}$

If we define a subclass of ==DiceHandle==, 
and send the message ==\+== to an instance

With ==handle := DiceHandle new==, ==\+== does not return an instance of the subclass but of ==DiceHandle==

With ==handle := self class new==, ==\+== returns an instance of the receiver: an instance of a potential subclass




${slide:title=Avoid magic numbers}$

- Do not hardcode magic numbers (55)
- Either define instance variables with setter and getter, and/or set default value via message semd

[[[language=smalltalk
    Node >> setWindowWithRatioForDisplay
        | averageRatio defaultNodeSize |
        averageRatio := 55.
        ...
]]]

${slide:title=Use Setter and Default}$

[[[language=smalltalk
    Node >> setWindowWithRatioForDisplay
        | averageRatio defaultNodeSize |
        averageRatio := self defaultAverageRatio.
        ...
]]]

[[[language=smalltalk
    Node >> defaultAverageRatio
        ^ 55
]]]

- With setter, clients may change the value without subclassing
[[[language=smalltalk
    aNode averageRatio: 55
]]]

${slide:title=Conclusion}$

- Each time you send a message you create a hook where the code of a subclass may be executed instead of yours.
- Prefer small methods over long ones because it forces you to create more methods, hence more hooks.

