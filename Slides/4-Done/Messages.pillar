{
    "title":"Understanding Messages",
    "subtitle":"",
    "author":"StÃ©phane Ducasse and Damien Cassou",
    "complement":"http://stephane.ducasse.free.fr/ stephane.ducasse@inria.fr"
}

${slide:title=Only Objects and Messages|label=objectives}$

We ""only"" manipulate objects: mouse, booleans, arrays, numbers, compressed, strings, windows, scrollbars, canvas, files, trees, compilers, sound, url, socket, fonts, text, collections, stack, shortcut, streams, ...


and we send messages, messages, messages and messages (and closures)

${slide:title=Syntax}$

- Remember it was originally invented for kids 
- Programs look like little sentences
- Minimizing the number of parenthesis

${slide:title=Example}$

[[[language=smalltalk
    (ZnEasy getPng: 'http://a.tile.openstreetmap.org/8/126/87.png' asZnUrl) 
        asMorph openInWorld
]]]

${slide:title=Three Kinds of Messages}$

- Unary
-- ==1 class==, ==Browser open== 

- Binary (operators like)
-- ==1+2==, ==x ~~ nil==

- Keyword-based: 
-- ==2 between: 0 and: 5==

${slide:title=A Glimpse at Message Precedence}$


- (Msg) \> Unary \> Binary \> Keywords


- First we execute ==()==
- Then unary, then binary and finally keyword messages
- Minimize ==()== needs
- But let us start with messages


${slide:title=Guess!}$

- ==1 log==
- ==Browser open== 
- ==2 raisedTo: 5==
- =='hello', 'world'==
- ==10@20==
- ==point1 x==
- ==point1 distanceFrom: point2==

${slide:title=Guess}$

- ==1 log== (unary)
- ==Browser open== (unary)
- ==2 raisedTo: 5== (keyword)
- =='hello', 'world'== (binary)
- ==10@20== (binary)
- ==point1 x== (unary)
- ==point1 distanceFrom: point2== (keyword)


${slide:title=Unary Messages}$

[[[language=Smalltalk
    anObject aSelector
]]]


[[[language=Smalltalk
    1 class
    > SmallInteger
]]]

${slide:title=Unary Message Examples}$



[[[language=Smalltalk
    false not
    > true
]]]

[[[language=Smalltalk
    Date today
    > 24 May 2009
]]]

[[[language=Smalltalk
    Time now
    > 6:50:13 pm
]]]

[[[language=Smalltalk
    Float pi
    > 3.141592653589793
]]]

${slide:title=Did you notice? To any objects}$

- We sent messages to any objects!
- We sent messages classes too!
- There is no difference between sending a message to one object or to a class

[[[language=Smalltalk
    1 class
    > SmallInteger
]]]

[[[language=Smalltalk
    Date today
    > 27 June 2015
]]]

[[[language=Smalltalk
    Point selectors
    > #(#x #theta #quadrantOf: #onLineFrom:to:within: #bitShiftPoint: #< #scaleFrom:to: #sideOf: #'\\' #scaleTo: #grid: #'//' #asIntegerPoint #directionToLineFrom:to: ...) 
]]]

- Returns all the messages the class understand


${slide:title=A little query}$

- Let us query the system... and only filter the unary messages :)

[[[language=Smalltalk
    Point selectors select: #isUnary  
    > #(#x #theta #asIntegerPoint #r #negated #normalized #sign #degrees #isIntegerPoint #guarded #fourNeighbors #eightNeighbors #min #max #ceiling #normal #asPoint #y #abs #isPoint #angle #transposed #reciprocal #asFloatPoint #asNonFractionalPoint #rounded #leftRotated #floor #truncated #hash #deepCopy #fourDirections #rightRotated #isSelfEvaluating #asMargin #isZero)
]]]

- Easy :)



${slide:title=Binary Messages}$

[[[language=Smalltalk
    anObject aBinarySelector anArgument
]]]

- Used for arithmetic, comparison and logical operations
- One, two or three characters taken from:
-- \+ \- \/ \\ \* \~ \< \> \= \@ \% \| \& \! \? \,


${slide:title=Binary Message Examples}$

[[[language=Smalltalk
    1 + 2
    > 3
]]]

[[[language=Smalltalk
    2 > 3
    > false
]]]

[[[language=Smalltalk
    10@200 
    > 10@200
]]]

[[[language=Smalltalk
    'Black chocolate' , ' is good'
    > 'Black chocolate is good'
]]]


${slide:title=Keyword Messages}$

[[[language=Smalltalk
    anObject keyword1: argument1 keyword2: argument2
]]]    

equivalent to

[[[language=Smalltalk
    receiver.keyword1keyword2(argument1, argument2)
]]]


${slide:title=Keyword Messages for Javaists}$

[[[language=Smalltalk
    postman.send(mail,recipient);
]]]

${slide:title=Keyword Messages for Javaists}$

[[[language=Smalltalk
    postman.send(mail,recipient);
    postman . send ( mail , recipient );
]]]


${slide:title=Keyword Messages for Javaists}$

[[[language=Smalltalk
    postman.send(mail,recipient);
    postman . send ( mail , recipient );
    postman send mail recipient
]]]

${slide:title=Keyword Messages for Javaists}$

[[[language=Smalltalk
    postman.send(mail,recipient);
    postman . send ( mail , recipient );
    postman send mail recipient
    postman send mail to recipient
]]]

${slide:title=Keyword Messages for Javaists}$

[[[language=Smalltalk
    postman.send(mail,recipient);
    postman . send ( mail , recipient );
    postman send mail recipient
    postman send mail to recipient
    postman send: mail to: recipient
]]]


${slide:title=Keyword Messages for Javaists}$

[[[language=Smalltalk
    postman.send(mail,recipient);
    
    postman send: mail to: recipient
]]]

- The message is named ==send:to:== 
- It is sent to ==postman==
- With two arguments: ==mail== and ==recipient==


${slide:title=Message setX:}$

[[[language=Smalltalk
    10@20 setX: 2
    > 2@20
]]]

- We change the x value of the receiver (a point)

${slide:title=Message at:put:}$


[[[language=Smalltalk
    #('Calvin' 'hates' 'Suzie') at: 2 put: 'loves'
    > #('Calvin' 'loves' 'Suzie')
]]]

- #(...) creates an array
- ==at:put:== changes the value of the array element.
- arrays start at 1 in Pharo (i.e., first element is at index 1)


${slide:title=Message between:and:}$

[[[language=Smalltalk
    12 between: 10 and: 20
    > true
]]]

- Here the message ==between:and:== is sent to an integer
- Takes two arguments ==10== and ==20==


${slide:title=Quizz}$

- ==1 log==
- ==Browser open== 
- ==2 raisedTo: 5==
- =='hello', 'world'==
- ==10@20==
- ==point1 x==
- ==point1 distanceFrom: point2==


${slide:title=Composition: from left to right!}$

- Remember: (Msg) \> Unary \> Binary \> Keywords
- What happens when we have two messages of the same kind?
- From left to right
[[[language=Smalltalk
    1000 factorial class name  
    > LargePositiveInteger
]]]
is equivalent to 
[[[language=Smalltalk
    (((1000 factorial) class) name) 
]]]

- Ease the composition of messages.



${slide:title=Back to Message Precedence}$

Remember that we have only messages

- (Msg) \> Unary \> Binary \> Keywords
- From left to right

${slide:title=Precedence Example}$

[[[language=Smalltalk
    2 + 3 squared
    > 2 + 9
    > 11
]]]

- unary (squared) first then binary (==+==)

${slide:title=Precedence Example}$

[[[language=Smalltalk
    2 raisedTo: 3 + 2
    > 2 raisedTo: 5
    > 32
]]]

- binary (==+==) first then keyword-based (==raisedTo:==)

${slide:title=Precedence Example}$

[[[language=Smalltalk
    Color gray - Color white = Color black
    > aGray - aWhite = aBlack
    > aBlack = aBlack
    > true
]]]

- Unary then binary from left to right

${slide:title=Precedence Example}$

[[[language=Smalltalk
    1 class maxVal + 1 
    > 1073741824
]]]

- unary, unary and binary

[[[language=Smalltalk
    1 class
    > SmallInteger

    1 class maxVal
    > 1073741823
	
    1 class maxVal + 1
    > 1073741824
	
    (1 class maxVal + 1) class
    > LargePositiveInteger
]]]


${slide:title=Precedence Example}$

[[[language=Smalltalk
    (ZnEasy getPng: 'http://a.tile.openstreetmap.org/8/126/87.png' asZnUrl) asMorph openInWorld
]]]

- unary (==asZnUrl==), keyword (==getPng:==)
- then unary, unary


${slide:title=Parentheses take precedence!}$

[[[language=Smalltalk
    (0@0 extent: 100@100) bottomRight
    > (aPoint extent: anotherPoint) bottomRight
    > aRectangle bottomRight
    > 100@100
]]]

[[[language=Smalltalk
    0@0 extent: 100@100 bottomRight
    > Message not understood
    > 100 does not understand bottomRight
]]]

${slide:title=The price for simplicity}$

- Only messages: ==+== 
-- is a message, no precedence
-- can be redefined in domain classes 
- Simple
- One limit: no mathematical precedence

${slide:title=No mathematical precedence}$

[[[language=Smalltalk
    3 + 2 * 10
    > 5 * 10
    > 50
]]]

- should be rewritten using parentheses
[[[language=Smalltalk
    3 + (2 * 10)
    > 3 + 20
    > 23
]]]

[[[language=Smalltalk
    1/3 + 2/3
    > 7/3 /3
    > 7/9
]]]
- should be rewritten using parentheses
[[[language=Smalltalk
    (1/3) + (2/3)
    > 1
]]]


${slide:title=Quiz}$

Describe the order in which the messages are executed

- ==(10@20 corner: 100@200) topCorner==
- ==10@20 distanceFrom: 200@200==
- ==2 \+ 3 raisedTo: 3 \+ 2==


${slide:title=Message Sequence}$

[[[language=Smalltalk
    message1.
    message2.
    message3
]]]

- . is a separator, not a terminator,
- No need to put one at the end.

[[[language=Smalltalk
    | macNode pcNode node1 printerNode |
    macNode := Workstation withName: #mac.
    Transcript cr.
    Transcript show: 1 printString.
    Transcript cr.
    Transcript show: 2 printString
]]]

${slide:title=Multiple messages to an object}$

- To send multiple messages to the same object

[[[language=Smalltalk
    Transcript show: 1 printString.
    Transcript cr
]]]

is equivalent to:

[[[language=Smalltalk
    Transcript
        show: 1 printString ;
        cr 
]]]


${slide:title=A puzzle}$
Imagine we want to add 2 to a new set.
[[[language=Smalltalk
    Set new add: 2
    > 2
]]]

- The message ==add:== returns its argument and not the receiver.
- We have to use a temporary variable.
[[[language=Smalltalk
    | s |
    s := Set new.
    s add: 1; add: 2.
    s 
]]]

- What could be another solution?


${slide:title=A puzzle}$

[[[language=Smalltalk
    Set new add: 2
    > 2
]]]

- The message ==add:== returns its argument and not the receiver.
- We have to use a temporary variable.
[[[language=Smalltalk
    | s |
    s := Set new.
    s add: 1; add: 2.
    s 
]]]

- What could be another solution?


${slide:title=One Hint}$

- What if we get a message that returns the receiver?

${slide:title=yourself}$

[[[language=Smalltalk
Object>>yourself
    ^ self
]]]


${slide:title=Solution}$

[[[language=Smalltalk
    | s |
    s := Set new.
    s add: 1; add: 2.
    s 
]]]
is equivalent to 

[[[language=Smalltalk
    Set new add: 1; add: 2; yourself
    > aSet 
]]]

${slide:title=Summary}$

- Three kinds of messages: unary, binary and keywords
- Arguments are placed inside message structure: 
-- 2 between: 0 and: 5 (the message is ==between:and:==)
- ==()== takes precedence over messages
- . is a separator
- ; is useful to avoid to repeat receiver
