{
	"title":"Objects, Methods, and Messages"
}



${slide:title=Not implementation in two methods}$

+Not implementation.>file://figures/BooleanHiearchyAndInstancesWithNotMethodsLookup.png|width=95+

${slide:title=Stepping back}$
- Let's the receiver decide
- Do not ask, tell

${slide:title=Ok so what?}$

- You will probably never implement ==Booleans== in the future
- So is it really that totally useless?
- What is the lesson to learn?



${slide:title=Message sends act as case statements}$

- Message sends act as case statements
- But with messages, the case statements is dynamic in the sense that it depends on the classes loaded and the objects to which the message is sent.

${slide:title=Sending a message is making a choice}$

- The execution engine will select the right method depending on the class of the receiver.
- Each time you send a message, the system will select the method corresponding to the receiver.
- Sending a message is a choice operator.


${slide:title=Question}$

Could we have been able to implement the same implementation in only one class?

${slide:title=Question}$

Could we have been able to implement the same implementation in only one class?
- No
- NO
- NO

${slide:title=Classes Play Case Roles}$

- To have the possibility to activate the choice operator you must have choices = classes
- A class implements a case

${slide:title=A Class Hierarchy is a Skeleton for Dynamic Dispatch}$

Compare the solution with one class vs. a hierarchy
- we can easily execute methods associated with one class
- just need one object of that class

+One single class vs. a nice hierarchy.>file://figures/Design-FatVsDispatch.png|width=80+


${slide:title=Advantages of Small Class Hierarchy}$

+One single class vs. a nice hierarchy.>file://figures/Design-FatVsDispatch.png|width=60+

- The hierarchy provides a way to specialize behavior
- You only focus on one class at a time
- It is more modula : you can package different classes in different packages
- You can also load classes separately 


${slide:title=Do not Ask, Tell}$

- Sending a message lets the receiver decide
- The client does not have to decide
- Client code is not fixed
- Different receivers may be substitued dynamically


${slide:title=Avoid Conditionals}$

- Use objects and messages, when you can
- The execution engine acts as a conditional switch: Use it!
- Check the AntiIfCampaign

${slide:title=Follow-up: Implement ternary logic}$

- Boolean: ==true==, ==false==, ==unknown==
+Ternary logic decision table.>file://figures/ArrayBoolean.png|width=60|label=fig:ternLogic+

- Implementing the solution with your own classes.

${slide:title=Cornerstone of OOP}$
- Tell, do not ask
- Let the receiver decide
- Message sends act as potential dynamic conditional
- Class hiearchy builds a skeleton for dynamic dispatch
- Avoid conditional
