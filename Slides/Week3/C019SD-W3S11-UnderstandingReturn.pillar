{
  "title":"Understanding Return"
}

${slide:title=What you will Learn}$

- How return really behaves

${slide:title=4 Cases}$

- Method with a return statement
- Method without a return statement
- Block without a return statement
- Block with a return statement

${slide:title=Returning a Different Object than self}$

Method with explicit return, just return the value of the expression

[[[
Number >> squared
	"Answer the receiver multipled by itself."

	^ self * self
]]]
	

${slide:title=Methods Return self by Default}$

Methods without explicit return return ==self==

[[[
Game >> initializePlayers
  self players
    at: 'tileAction'
    put: ( MITileAction director: self )
]]]

equivalent to

[[[
Game >> initializePlayers
  self players
    at: 'tileAction'
    put: ( MITileAction director: self )
  ^ self       "<-- this is optional"
]]]


${slide:title=Yourself}$

[[[
Object >> yourself
   ^ self 
]]]


${slide:title=Blocks without explicit return}$

Blocks return the value of their last expresssion

[[[
   [ :x |
      x + 33.
      x + 2 ] value: 5
   > 7
]]]

${slide:title=Returning from a Block Returns from the Method}$

When a return ==^== is executed in a block, computation exits the method

[[[
Integer>>factorial
   "Answer the factorial of the receiver."

   self = 0 ifTrue: [ ^ 1 ].
   self > 0 ifTrue: [ ^ self * (self - 1) factorial ].
   self error: 'Not valid for negative integers'
]]]

${slide:title=More Precisely}$

- When returning from a block, the method ""defining"" the block is terminated
- Since blocks can be passed around in variables, blocks behave like an exception mechanism
- Prefer exceptions when this is what you need them
- Further readings: *http://deepintopharo.org*


${slide:title=What you Should Know}$

- Return from methods, return the value of the expression
- Return from block are skipping definition method


