{
    "title":"Iterators"
}

${slide:title=What you Will Learn}$

- Understand the power of iterators
- Offer an overview of iterators

${slide:title=Pharo code is Compact!}$

[[[language=Java
ArrayList<String> strings = new ArrayList<String>();
  for(Person person: persons)
          strings.add(person.name());
]]]
is expressed as
[[[
strings := persons collect: [ :person | person name ]
]]]

- Yes in Java 8.0 it is finally simpler 
[[[
strings = persons.stream().map(person -> person.getName())
]]]
- But it is like that in Pharo since day one!
- Iterators are deep into the core of the language and libraries

${slide:title= A first iterator: collect:}$

 ==collect:== applies the block to each element and returns a collection (of the same kind than the receiver) with the results

[[[
  #(2 -3 4 -35 4) collect: [ :each | each abs ]
  > #(2 3 4 35 4)
]]]

- ==collect:== sends the message ==abs== (absolute) to each element of the receiver 
- and returns the resulting collection.
- [Think object] We ask the collection to do something for us.

${slide:title=Another collect: example}$

We want to know if each elements is odd or even.

[[[
    #(16 11 68 19) collect: [ :i | i odd ]
]]]

[[[
    >  #(false true false true)
]]]


${slide:title=Choose your camp!}$

[[[
  #(16 11 68 19) collect: [ :i | i odd ]
]]]

- We can also do it that way!
[[[language=smalltalk
  | result |
  aCol :=  #(16 11 68 19).
  result := aCol species new: aCol size.
  1 to: aCollection size do:
      [ :each | result at: each put: (aCol at: each) odd ].
  ^ result
]]]

(We copied the definition of ==collect:== but 
this is error prone, verbose and tedious)



${slide:title=Part of the collection hierarchy}$

Iterators work polymorphically on the entire collection hierarchy.

+Part of the Collection hierarchy.>file://figures/CollectionHierarchy.png|width=100+
Part of the Collection hierarchy.


${slide:title=Think objects!}$

- With iterators we ""tell"" the collection to ""iterate on itself""
- As a client we do not have to know the internal logic of the collection
- Each collection can implement differently the iterator


${slide:title=Basic Iterators Overview}$

- ==do:== (iterate)
- ==collect:== (iterate and collect results)
- ==select:== (select matching elements)
- ==reject:== (reject matching elements)
- ==detect:== (get first element matching)
- ==detect:ifNone:== (get first element matching or a default value)
- ==includes:== (test inclusion)
- and a lot more...


${slide:title=do: an action on each element}$

- Iterates on each elements
- Applies the block on each elements

[[[
  #(16 11 68 19) do: [ :each | Transcript show: each ; cr ]
]]]

Here we print each elements and insert a carriage return

+Results of do: >file://figures/Iterators-Transcript.png|width=80|label=Iterators-Transcript+


${slide:title=select: elements matching a criteria}$

To select some elements, use ==select:==

[[[
  #(16 11 68 19) select: [ :i | i odd ]
  > #(11 19)
]]]

${slide:title=With unary messages, no block needed}$

When a block expects a single argument, we can pass an unary message selector
[[[
  #(16 11 68 19) select: [ :i | i odd ]
]]]

is equivalent to

[[[language=smalltalk
    #(16 11 68 19) select: #odd
]]]


${slide:title=reject: elements matching a criteria}$

To filter some elements, use ==reject:==

[[[
  #(16 11 68 19) reject:  [ :i | i odd ]
  > #(16 68)
]]]


${slide:title=detect: the first elements that...}$

To find the first element that matches, use ==detect:==

[[[
  #(16 11 68 19) detect:  [ :i | i odd ]
  > 11
]]]



${slide:title=detect:ifNone:}$

To find the first element that matches else return a value, use ==detect:ifNone:==

[[[
  #(16 12 68 20) detect:  [ :i | i odd ] ifNone: [ 0 ]
  > 0
]]]

${slide:title=Some Powerful Iterators}$

- ==anySatisfy:== (tests if one object is satisfying the criteria)
- ==allSatisfy:== (tests if all objects are satisfying the criteria)
- ==reverseDo:== (do an action on the collection starting from the end)
- ==doWithIndex:== (do an action with the element and its index)
- ==pairsDo:== (evaluate aBlock with my elements taken two at a time.)
- ==permutationsDo:== ...

${slide:title=Exercises}$

Propose some expressions to illustrate the uses of 
- ==anySatisfy:== 
- ==allSatisfy:== 
- ==reverseDo:== 
- ==doWithIndex:== 
- ==pairsDo:== 
- ==permutationsDo:==

${slide:title=Some cool iterators}$

 How to produce?
[[[
    #('a' 'b' 'c') message
    > 'a, b, c'

    #('a') message
    > 'a'
	
    #() message
    > ''
]]]

${slide:title=Use doSeparatedBy:}$


[[[
  String streamContents: [ :s |
            #('a' 'b' 'c')
                do: [ :each | s << each ]
                separatedBy: [ s << ', ' ]
            ]
]]]


${slide:title=Iterating two structures}$

To iterative ==with:do:==
[[[
#(1 2 3)
    with:  #(10 20 30)
    do: [ :x :y | Transcript show: (y * x) ; cr ]
]]]

+Results of with:do: >file://figures/Iterator-WithDo-Transcript.png|width=70|label=Iterator-WithDo-Transcript+

- ==with:do:== requires two structures of the same length.

${slide:title=Grouping elements}$

To group elements according to a grouping function: ==groupedBy:==

[[[
  #(1 2 3 4 5 6 7 ) groupedBy: #even
  > a PluggableDictionary(false->#(1 3 5 7) true->#(2 4 6) )
]]]


${slide:title=Flattening results}$

How to remove one level of nesting in a collection? Use ==flatCollect:==

[[[
  #( #(1 2) #(3) #(4) #(5 6))) collect: [ :each | each ]
  > #(#(1 2) #(3) #(4) #(5 6)))
]]]

[[[
  #( #(1 2) #(3) #(4) #(5 6))) flatCollect: [ :each | each ]
  > #(1 2 3 4 5 6 ))
]]]

${slide:title=Opening the box}$

- You can learn and discover the system
- You can define your own iterator
- For example how ==do:== is implemented?
[[[
SequenceableCollection >> do: aBlock
  "Evaluate aBlock with each of the receiver's elements as the argument."

  1 to: self size do: [:i | aBlock value: (self at: i)]
]]]

${slide:title=Analysis}$

- Iterators are really powerful because they support polymorphic code.
- All the collections support them.
- New ones are defined.
- Missing controlled navigation as in the Iterator design pattern.

${slide:title=Summary}$
- Iterators are your best friends
- Simple and powerful
- Enforce encapsulation of collections and containers