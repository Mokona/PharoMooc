{
	"title":"Roots of Dispatch and Objects"
}

${slide:title=Objectives}$

- Understanding of message passing (late binding)
-- the heart of OOP
-- more an OOP lecture than a Pharo one
- Insight at how beautiful Pharo's implementation is

${slide:title=Context: Booleans}$

In Pharo, Booleans have a superb implementation!

- ==&==, ==|==, ==not== (eager)
- ==or:==, ==and:== (lazy)
- ==ifTrue:ifFalse:==, ==ifFalse:ifTrue:==

${slide:title=Three Exercises}$

# Implement ==not==
# Implement ==|== (or) and ==ifTrue:ifFalse:==
# What is the goal of these exercises?

${slide:title=Exercise 1: Implement not}$

- Propose an implementation of ==not== in a world where:
-- you have Booleans but not operations
-- you only have objects and messages
[[[
   false not
   -> true

   true not
   -> false
]]]

${slide:title=Exercise 2: Implement OR}$

- Propose an implementation of ==or== in a world where:
-- you do not have Booleans
-- you only have objects and messages

[[[
   true | true -> true
   true | false -> true
   true | anything -> true

   false | true -> true
   false | false -> false
   false | anything -> anything
]]]

${slide:title=Hint 1: No conditionals}$

The solution does not use conditionals (i.e., no ==if==)

${slide:title=Hint 2: At Least Three Classes}$

- The solution uses three classes:
-- ==Boolean==, ==True== and ==False==
- ==true== is the singleton instance of ==True==
- ==false== is the singleton instance of ==False==

${slide:title=Hint 2: At Least Three Classes}$

+Boolean Hierarchy>file://figures/BooleanHiearchyAndInstances.png|width=75+

${slide:title=Hint 3: How do we express choice in OOP?}$

- By defining classes with compatible methods
- By sending a message to an instance of such class


${slide:title=Hint 3: Define Methods and Send Messages}$

[[[
   x color
   -> Color red
]]]

- ==x== can be a button, a pane, a window, a bird, ...
- the method is ""chosen"" based on the ==x=='s class

${slide:title=Implementation of not in two methods}$

[[[
False>>not
   "Negation -- answer true since the receiver is false."
   ^ true
]]]

[[[
True>>not
   "Negation -- answer false since the receiver is true."
   ^ false
]]]

${slide:title=Implementation of not in two methods}$

+Not implementation.>file://figures/BooleanHiearchyAndInstancesWithNotMethods.png|width=110+


${slide:title=Implementation of not in two methods}$

+Not implementation.>file://figures/BooleanHiearchyAndInstancesWithNotMethodsLookup.png|width=110+


${slide:title=Boolean Implementation}$

- ==Boolean== is abstract
- subclasses are ==True== and ==False== and implement
-- logical operations ==&==, ==not==
-- control structures ==and:==, ==or:==, ==ifTrue:==, ==ifFalse:==, ==ifTrue:ifFalse:==, ==ifFalse:ifTrue:==

[[[
Boolean>>not
   "Abstract method. Negation: Answer true if the receiver is false, answer false if the receiver is true."
   self subclassResponsibility
]]]

${slide:title=Behavior of OR}$

[[[
true | true -> true
true | false -> true
true | anything -> true
]]]

[[[
false | true -> true
false | false -> false
false | anything -> anything
]]]

${slide:title=Implementation of OR in Boolean}$

[[[
Boolean>>| aBoolean
   "Abstract method. Evaluating OR: Evaluate the argument.
   Answer true if either the receiver or the argument is true."
   self subclassResponsibility
]]]


${slide:title=Implementation of OR in False}$

[[[
false | true -> true
false | false -> false
false | anything -> anything
]]]

[[[
False>>| aBoolean
   "Evaluating OR -- answer with the argument, aBoolean."
   ^ aBoolean
]]]

${slide:title=Implementation of OR in True}$

[[[
true | true -> true
true | false -> true
true | anything -> true
]]]

[[[
True>>| aBoolean
   "Evaluating OR -- answer true since the receiver is true."
   ^ true
]]]

${slide:title=Real implementation of OR in True}$

[[[
True>>| aBoolean
   "Evaluating disjunction (OR) -- answer true since the receiver is true."
   ^ true
]]]

The object ==true== is indeed the receiver of the message!

[[[
True>>| aBoolean
   "Evaluating disjunction (OR) -- answer true since the receiver is true."
   ^ self
]]]

${slide:title=OR Implementation in Two Methods}$

+Boolean hierarchy and instances.>file://figures/BooleanHiearchyAndInstancesWithOrMethods.png|width=110+


${slide:title=Summary}$
- The solution to implement booleans' operations:
-- does NOT use conditionals (if)
-- let the receiver decides
- Do not ask, tell

% Local Variables:
% compile-command: "cd ../.. && ./compile.sh --to=Beamer Slides/Week3/C019SD-W3S01-Design-EssenceOfDispatchNot.pillar"
% End:
