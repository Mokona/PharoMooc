{
	"title":"Roots of Dispatch and Objects"
}

${slide:title=Objectives}$

- understanding of message passing (late binding)
-- the heart of OOP
-- more an OOP lecture than a Pharo one
- insight at how beautiful Pharo's implementation is

${slide:title=Context: Booleans}$

In Pharo, Booleans have a superb implementation!

- ==&==, ==|==, ==not== (eager)
- ==or:==, ==and:== (lazy)
- ==ifTrue:ifFalse:==, ==ifFalse:ifTrue:==

${slide:title=Three Exercises}$

# Implement ==not==
# Implement ==|== (or) and ==ifTrue:ifFalse:==
# What is the goal of these exercises?

${slide:title=Exercise 1: Implement not}$

- Propose an implementation of ==not== in a world where:
-- you have Booleans but not operations
-- you only have objects and messages
[[[
   false not
   -> true

   true not
   -> false
]]]

${slide:title=Exercise 2: Implement \| (or)}$

- Propose an implementation of ==not== in a world where:
-- you do not have Booleans
-- you only have objects and messages

[[[
   true | true -> true
   true | false -> true
   true | anything -> true

   false | true -> true
   false | false -> false
   false | anything -> anything
]]]

${slide:title=Hint 1: No conditionals}$

The solution does not use conditionals (i.e., no ==if==)

${slide:title=Hint 2: At Least Two Classes}$

- The solution uses three classes:
-- ==Boolean==, ==True== and ==False==
- ==true== is the singleton instance of ==True==
- ==false== is the singleton instance of ==False==

${slide:title=Hint 2: At Least Two Classes}$

+Boolean Hierarchy>file://figures/BooleanHiearchyAndInstances.png|width=75+

${slide:title=Hint 3: Define Methods and Send Messages}$

How do we express choice in OOP?
- by defining classes with compatible methods
- by sending a message to an instance of such class

[[[
   x color
   -> Color red
]]]

- ==x== can be a button, a pane, a window, a bird, ...
- the method is ""chosen"" based on the ==x=='s class

${slide:title=Implementation of not in two methods}$

[[[
False>>not
   "Negation -- answer true since the receiver is false."
   ^ true
]]]

[[[
True>>not
   "Negation -- answer false since the receiver is true."
   ^ false
]]]

${slide:title=Implementation of not in two methods}$

+Not implementation.>file://figures/BooleanHiearchyAndInstancesWithNotMethods.png|width=90+


${slide:title=Implementation of not in two methods}$

+Not implementation.>file://figures/BooleanHiearchyAndInstancesWithNotMethodsLookup.png|width=90+


${slide:title=Boolean implementation}$

- Class ==Boolean== is abstract and implements common behavior
- Its subclasses are ==True== and ==False==
- Subclasses implement
-- logical operations ==&==, ==not==
-- control structures ==and:==, ==or:==, ==ifTrue:==, ==ifFalse:==, ==ifTrue:ifFalse:==, ==ifFalse:ifTrue:==

[[[
Boolean>>not
   "Abstract method. Negation: Answer true if the receiver is false, answer false if the receiver is true."
   self subclassResponsibility
]]]

${slide:title=\| (Or)}$

[[[
  true | true -> true
  true | false -> true
  true | anything -> true
]]]

[[[
  false | true -> true
  false | false -> false
  false | anything -> anything
]]]

${slide:title=False >> \| aBoolean}$

[[[
  false | true -> true
  false | false -> false
  false | anything -> anything
]]]

${slide:title=False >> \| aBoolean}$

[[[
  false | true -> true
  false | false -> false
  false | anything -> anything
]]]

[[[
  False >> | aBoolean
    "Evaluating OR -- answer with the argument, aBoolean."
    ^ aBoolean 
]]]


${slide:title=True >> \| aBoolean}$

[[[
  true | true -> true
  true | false -> true
  true | anything -> true
]]]

${slide:title=True >> \| aBoolean}$

[[[
  true | true -> true
  true | false -> true
  true | anything -> true
]]]

[[[
  True >> | aBoolean
    "Evaluating OR -- answer true since the receiver is true."
    ^ true
]]]


${slide:title=Boolean >> \| aBoolean}$

[[[
  Boolean >> | aBoolean
    "Abstract method. Evaluating OR: Evaluate the argument. 
	Answer true if either the receiver or the argument is true."
    self subclassResponsibility
]]]




${slide:title=Real implementation of True >> \| aBoolean}$


[[[
  True >> | aBoolean
    "Evaluating disjunction (OR) -- answer true since the receiver is true."
    ^ true
]]]

The object ==true== is indeed the receiver of the message!

[[[
  True >> | aBoolean
    "Evaluating disjunction (OR) -- answer true since the receiver is true."
    ^ self
]]]


${slide:title=Or implementation in two methods}$

+Boolean hierarchy and instances.>file://figures/BooleanHiearchyAndInstancesWithOrMethods.png|width=90+


${slide:title=Stepping back}$
- We did NOT use condition, we did not ask anything
- Let's the receiver decide
- Do not ask, tell

% Local Variables:
% compile-command: "cd ../.. && ./compile.sh --to=Beamer Slides/Week3/C019SD-W3S01-Design-EssenceOfDispatchNot.pillar"
% End:
