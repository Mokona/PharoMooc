{
	"title":"To the Roots of Dispatch and Objects"
}

${slide:title=Objectives}$

- Deep understanding of late binding essence
- More an object-oriented design lecture than a Pharo lecture
- But it is looking at how beautiful Pharo's implementation is

${slide:title=A Key Point}$

- Message passing (late binding) is the heart of object-oriented programming

- The lecture revisits this essential and fundamental aspect of OOP using some simple examples

- After this lecture you will never look the same your programs.

${slide:title=Context: Booleans}$

In Pharo, Booleans have nothing special, just a superb implementation!
- & | not (eager)
- or: and: (lazy)
- ifTrue:ifFalse:
- ifFalse:ifTrue:
- =>
- ....

${slide:title=Three Exercises}$

-1 Implement ==not==
-2 Implement ==|== (or)
-3 What these exercises illustrate?



${slide:title=Exercise 1\: Implement not}$

- Propose an implementation of ==not== in a world where you do not have Booleans implemented yet.
- You only have objects and messages.

[[[
  false not 
  -> true
]]]

[[[
  true not 
  -> false
]]]

${slide:title=Exercise 2\: Implement \| (Or)}$
- Propose an implementation of ==or== (named ==|== in Pharo) in a world where you do not have Booleans.
- You only have objects and messages.

[[[
  true | true -> true
  true | false -> true
  true | anything -> true
]]]

[[[
  false | true -> true
  false | false -> false
  false | anything -> anything
]]]

${slide:title=Hint 1: No conditionals}$

- The solution does not use conditionals!

- We would obtain a recursive definition of ==ifTrue:ifFalse:== 

${slide:title=Hint 2: At Least Two Classes}$

- The solution uses three classes: ==Boolean==, ==True== and ==False==
- ==false== and ==true== are unique instances described by their own classes 
- ==false== is an instance of the class ==False==
- ==true== is an instance of the class ==True==

${slide:title=Hint 2: At Least Two Classes}$

+Boolean Hierarchy>file://figures/BooleanHiearchyAndInstances.png|width=75+

${slide:title=Hint 3: Define Methods and Send Messages}$

How do we express choice in OOP?
- We define methods in different classes 
- We send messages to objects

[[[
  ...
  x color
  -> Color red
]]]
	
- ==x== can be a button, a pane, a window, a magic card, a bird



${slide:title=Not implementation in two methods}$

[[[
  False >> not
    "Negation -- answer true since the receiver is false."
    ^ true
]]]

[[[ 
  True >> not
    "Negation -- answer false since the receiver is true."
    ^ false
]]]

${slide:title=Not implementation in two methods}$

+Not implementation.>file://figures/BooleanHiearchyAndInstancesWithNotMethods.png|width=90+


${slide:title=Not implementation in two methods}$

+Not implementation.>file://figures/BooleanHiearchyAndInstancesWithNotMethodsLookup.png|width=90+


${slide:title=Boolean not implementation}$

- Class ==Boolean== is an abstract class that implements behavior common to true and false. 
- Its subclasses are ==True== and ==False==. 
- Subclasses just implement methods for logical operations ==&==, ==not==, and controls ==and:==, ==or:==, ==ifTrue:==, ==ifFalse:==, ==ifTrue:ifFalse:==, ==ifFalse:ifTrue:==

[[[
  Boolean >> not
    "Abstract method. Negation: Answer true if the receiver is false, answer false if the receiver is true."
    self subclassResponsibility
]]]



${slide:title=\| (Or)}$

[[[
  true | true -> true
  true | false -> true
  true | anything -> true
]]]

[[[
  false | true -> true
  false | false -> false
  false | anything -> anything
]]]

${slide:title=False>> \| aBoolean}$

[[[
  false | true -> true
  false | false -> false
  false | anything -> anything
]]]

${slide:title=False >> \| aBoolean}$

[[[
  false | true -> true
  false | false -> false
  false | anything -> anything
]]]

[[[
  False >> | aBoolean
    "Evaluating OR -- answer with the argument, aBoolean."
    ^ aBoolean 
]]]


${slide:title=True >> \| aBoolean}$

[[[
  true | true -> true
  true | false -> true
  true | anything -> true
]]]

${slide:title=True>> \| aBoolean}$

[[[
  true | true -> true
  true | false -> true
  true | anything -> true
]]]

[[[
  True>> | aBoolean
    "Evaluating OR -- answer true since the receiver is true."
    ^ true
]]]


${slide:title=Boolean>> \| aBoolean}$

[[[
  Boolean >> | aBoolean
    "Abstract method. Evaluating OR: Evaluate the argument. 
	Answer true if either the receiver or the argument is true."
    self subclassResponsibility
]]]




${slide:title=Real implementation of True>> \| aBoolean}$


[[[
  True >> | aBoolean
    "Evaluating disjunction (OR) -- answer true since the receiver is true."
    ^ true
]]]

The object ==true== is indeed the receiver of the message!

[[[
  True >> | aBoolean
    "Evaluating disjunction (OR) -- answer true since the receiver is true."
    ^ self
]]]


${slide:title=Or implementation in two methods}$

+Boolean hierarchy and instances.>file://figures/BooleanHiearchyAndInstancesWithOrMethods.png|width=90+


${slide:title=Stepping back}$
- We did use condition, we did not ask anything
- Let's the receiver decide
- Do not ask, tell

