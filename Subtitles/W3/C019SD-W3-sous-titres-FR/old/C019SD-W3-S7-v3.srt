1
00:00:01,080 --> 00:00:04,780
Alors dans cette séquence
nous allons voir les éléments

2
00:00:05,000 --> 00:00:07,290
essentiels de la
hiérarchie des collections en Faro.

3
00:00:07,770 --> 00:00:09,910
Donc vous allez voir que
Faro est riche du point de vue

4
00:00:10,110 --> 00:00:14,070
des différents types de
collections, mais il facilite la

5
00:00:14,270 --> 00:00:17,000
vie du programmeur puisqu'ils
présentent tous une API commune.

6
00:00:17,720 --> 00:00:20,790
Et on verra également la
différence entre les collections

7
00:00:21,030 --> 00:00:22,640
littérales et les
collections dynamiques.

8
00:00:24,170 --> 00:00:26,360
Donc là l'API des
collections, comme je disais, est

9
00:00:26,560 --> 00:00:28,550
riche, on verra qu'il y a beaucoup
de types de collections différents.

10
00:00:29,000 --> 00:00:31,590
Toutes présentent une API
commune, on le verra, qui est

11
00:00:31,790 --> 00:00:34,910
assez bien organisée, qui facilite
énormément la vie du programmeur.

12
00:00:36,040 --> 00:00:39,000
Petit point particulier en
Faro les collections, les

13
00:00:39,200 --> 00:00:41,910
index des collections,
commencent à 1 alors que ça

14
00:00:42,110 --> 00:00:43,500
commence à 0 dans d'autres langages.

15
00:00:44,330 --> 00:00:46,630
Et puis les collections
peuvent contenir n'importe quel

16
00:00:46,830 --> 00:00:49,180
type d'objet en Faro, ce
qui n'est pas forcément le cas

17
00:00:49,380 --> 00:00:50,140
dans dans les autres langages.

18
00:00:51,700 --> 00:00:54,530
Donc quelques-unes des
collections les plus remarquables

19
00:00:54,730 --> 00:00:56,600
et les plus utilisées, donc
(inaudible) collection qui

20
00:00:56,800 --> 00:01:00,370
est une collection dynamique
dont la taille va grossir à

21
00:01:00,570 --> 00:01:02,230
chaque fois qu'on
ajoute des éléments dedans.

22
00:01:02,530 --> 00:01:05,410
(inaudible) qui est une
collection de taille fixe.

23
00:01:05,880 --> 00:01:07,820
Et puis on va accéder aux
éléments en fonction d'un

24
00:01:08,020 --> 00:01:12,910
indice (inaudible), qui va
contenir des éléments mais sans doublon.

25
00:01:13,450 --> 00:01:16,000
On ne pourra pas insérer 2
fois le même élément dans un set.

26
00:01:16,330 --> 00:01:18,520
Et puis les dictionnaires,
donc les dictionnaires ce sont

27
00:01:18,720 --> 00:01:21,040
des tables de la (inaudible) à
une clé donnée j'associe une valeur.

28
00:01:22,160 --> 00:01:24,340
Donc vous avez ici un
extrait de la hiérarchie des

29
00:01:24,540 --> 00:01:25,770
collections, c'est
seulement un extrait.

30
00:01:26,000 --> 00:01:28,080
Il est plus riche que ça en Faro.

31
00:01:28,280 --> 00:01:29,580
Donc voyez qu'il y
a plein de classes.

32
00:01:29,780 --> 00:01:32,010
Elles héritent toutes de
collections, ce qui nous fournit

33
00:01:32,210 --> 00:01:33,680
une API commune pour
l'ensemble des collections.

34
00:01:34,800 --> 00:01:36,910
Et puis on va voir celles
qui sont en gras, on voit les

35
00:01:37,110 --> 00:01:39,260
expliciter un peu au fur et
à mesure de cette séquence.

36
00:01:40,690 --> 00:01:44,270
Donc il existe une API commune, je
vous disais, répartie en 7 points.

37
00:01:44,540 --> 00:01:46,550
On a des méthodes
spécifiques pour la création des

38
00:01:46,750 --> 00:01:49,270
collections, qu'on va envoyer
plutôt aux classes des collections.

39
00:01:49,530 --> 00:01:51,530
Des méthodes spécifiques
pour accéder aux propriétés des

40
00:01:51,730 --> 00:01:53,900
collections, que ce soit
accéder par exemple à la taille

41
00:01:54,330 --> 00:01:57,540
d'une collection ou accéder même aux
éléments que la collection contient.

42
00:01:58,150 --> 00:01:59,600
Des méthodes de
(inaudible), savoir est-ce que la

43
00:01:59,800 --> 00:02:02,170
collection est vide ou pas.
Des méthodes d'ajout et de

44
00:02:02,370 --> 00:02:04,120
retrait d'éléments, des
méthodes d'énumération des

45
00:02:04,320 --> 00:02:06,320
éléments dans une
collection. Donc je parcours l'ensemble

46
00:02:06,520 --> 00:02:09,370
des éléments, je voudrais
savoir si un élément existe,

47
00:02:09,570 --> 00:02:11,080
est présent dans
une collection ou pas.

48
00:02:11,580 --> 00:02:14,410
Et puis on a des méthodes
de conversion d'un type de

49
00:02:14,610 --> 00:02:15,500
collection en un autre type.

50
00:02:17,130 --> 00:02:18,200
Commençons par un exemple.

51
00:02:18,630 --> 00:02:21,600
Donc je veux créer une
collection en Faro tout bêtement.

52
00:02:21,800 --> 00:02:24,450
Je vais sélectionner la
bonne classe qui m'intéresse et

53
00:02:24,650 --> 00:02:26,510
lui envoyer un message new
pour instancier, pour créer un

54
00:02:26,710 --> 00:02:27,900
nouvel instant sur cette classe.

55
00:02:28,350 --> 00:02:30,240
Donc premier cas de
figure, j'utilise New.

56
00:02:30,630 --> 00:02:31,600
Deuxième cas de figure.

57
00:02:32,070 --> 00:02:34,260
En fait je ne peux pas
faire un New directement ou j'ai

58
00:02:34,460 --> 00:02:36,020
envie de spécifier la
taille de la collection.

59
00:02:36,430 --> 00:02:38,910
Donc typiquement
(inaudible) je peux lui envoyer New 4,

60
00:02:39,140 --> 00:02:41,220
donc je fais un tableau de
taille 4 ou un tableau de

61
00:02:41,420 --> 00:02:43,280
taille 2, donc ça marche
également sur les (inaudible) de

62
00:02:43,480 --> 00:02:45,220
collections je pourrais faire un
(inaudible) de collections (inaudible).

63
00:02:47,460 --> 00:02:50,440
Donc on a 2 types de
méthodes pour créer des collections

64
00:02:50,930 --> 00:02:53,850
pré-initialisées, donc avec
(inaudible) par exemple où je

65
00:02:54,050 --> 00:02:55,160
vais passer une collection littérale.

66
00:02:55,500 --> 00:02:57,470
Une collection littérale
ça commence par un dièse

67
00:02:57,670 --> 00:03:00,320
parenthèse, je vous
rappelle. Et puis ça va me créer donc

68
00:03:00,520 --> 00:03:01,910
une nouvelle instance
de la classe (inaudible)

69
00:03:02,110 --> 00:03:03,820
collection, donc un nouvel
(inaudible) collection qui

70
00:03:04,020 --> 00:03:06,070
contiendra bien tous les
éléments qui ont été placés au

71
00:03:06,270 --> 00:03:07,030
moment de sa création.

72
00:03:07,630 --> 00:03:10,060
Je peux faire la même chose
avec un 7, par contre je vous

73
00:03:10,260 --> 00:03:12,810
rappelle hein dans un 7 on ne
peut pas avoir d'objets doublons.

74
00:03:13,030 --> 00:03:15,750
Donc le chiffre 7 qu'on
avait mis 2 fois dans la

75
00:03:15,950 --> 00:03:18,700
collection littérale il ne peut
pas se retrouver 2 fois dans le 7.

76
00:03:21,300 --> 00:03:25,070
Donc il y a d'autres types,
d'autres sortes de messages

77
00:03:25,270 --> 00:03:27,860
qu'on peut envoyer aux classes
collection pour les initialiser.

78
00:03:28,140 --> 00:03:29,390
Ici j'en ai un autre exemple.

79
00:03:29,590 --> 00:03:32,850
"New with all", donc qui
est un message, je veux faire

80
00:03:33,050 --> 00:03:35,390
une collection de taille 5
mais je veux que toutes les

81
00:03:35,590 --> 00:03:37,100
 classes soient
initialisées avec un certain objet.

82
00:03:37,370 --> 00:03:39,450
Donc en l'occurrence ici
une Stream qui contient.

83
00:03:42,470 --> 00:03:46,230
Donc subtilité en Faro toutes les
collections commencent à l'indice 1.

84
00:03:46,680 --> 00:03:49,780
Donc si je demande à cette
collection de 3 éléments de me

85
00:03:50,000 --> 00:03:52,470
rendre l'élément à l'indice
2, c'est bien (inaudible).

86
00:03:52,670 --> 00:03:53,430
Donc c'est bien celui-là.

87
00:03:53,780 --> 00:03:55,920
Ça c'est 1, ça c'est 2, ça c'est 3.

88
00:03:57,260 --> 00:03:58,650
Donc c'est la même chose
pour les (inaudible) collection,

89
00:03:59,150 --> 00:04:01,090
si je convertis cette
collection en (inaudible)

90
00:04:01,290 --> 00:04:02,730
collection et je lui demande
son élément indice 2, ça me

91
00:04:02,930 --> 00:04:04,210
revient (inaudible) la même chose.

92
00:04:05,950 --> 00:04:08,890
Donc les collections peuvent
contenir toutes sortes d'objets,

93
00:04:09,090 --> 00:04:12,380
comme je l'ai dit, et ici
je vous en montre un exemple

94
00:04:12,580 --> 00:04:15,190
cette collection littérale
va contenir, dans son premier

95
00:04:15,390 --> 00:04:17,590
élément, la chaîne des
caractères (inaudible), et dans

96
00:04:17,790 --> 00:04:21,460
son second élément une collection
qui contiendra les nombres 1, 2, 3.

97
00:04:22,150 --> 00:04:25,360
Je peux créer par exemple un
tableau, donc ici ce tableau

98
00:04:25,560 --> 00:04:30,000
il est composé des éléments 1, 2 ici

99
00:04:31,060 --> 00:04:32,490
et d'un 7 à la fin.

100
00:04:33,280 --> 00:04:36,960
Donc l'élément 1 a été ajouté
ici, l'élément 2 ici et le 7 ici.

101
00:04:38,240 --> 00:04:40,180
Donc on peut maintenant
parcourir les éléments d'une

102
00:04:40,380 --> 00:04:43,810
collection, en utilisant
le message "Do" par exemple.

103
00:04:44,730 --> 00:04:49,000
Donc ici j'ai une collection et je
vais lui envoyer le message "Do".

104
00:04:49,690 --> 00:04:53,260
Je vais lui passer un bloc,
donc je vous rappelle le bloc

105
00:04:53,460 --> 00:04:55,940
ici il commence avec le
crochet ouvrant, il se ferme avec

106
00:04:56,140 --> 00:04:59,040
le crochet fermant. Le
paramètre du bloc il s'appelle

107
00:04:59,240 --> 00:05:00,890
"Each", donc qui
commence par un 2 points.

108
00:05:01,090 --> 00:05:03,850
Il est séparé du corps de
bloc par la barre verticale et

109
00:05:04,050 --> 00:05:06,410
on va à chaque tour de
boucles, "Each" vaudra le premier

110
00:05:06,610 --> 00:05:08,550
élément de la collection, le
deuxième et cetera jusqu'à la fin.

111
00:05:08,920 --> 00:05:11,480
Donc on va bien afficher sur
le Transcripte (inaudible).

112
00:05:14,640 --> 00:05:15,400
Donc on a les tableaux.

113
00:05:16,110 --> 00:05:18,190
Donc les tableaux c'est des
collections de taille fixe.

114
00:05:18,410 --> 00:05:21,820
Donc on peut demander à un tableau sa
taille, j'y envoie le message "Size".

115
00:05:22,580 --> 00:05:25,160
On peut accéder directement
à un élément d'un tableau en

116
00:05:25,360 --> 00:05:28,050
lui envoyant le message "At:", je
veux l'élément 2 de la collection.

117
00:05:28,250 --> 00:05:31,080
On peut modifier
l'élément à l'indice 2 dans la

118
00:05:31,280 --> 00:05:34,240
collection en envoyant
"At1 put (inaudible)".

119
00:05:35,730 --> 00:05:38,240
Donc je vais insérer la
chaîne (inaudible) dans la case 1.

120
00:05:39,360 --> 00:05:40,630
Et puis je peux demander la taille.

121
00:05:40,830 --> 00:05:45,040
L'élément intéressant ici
dans cet exemple c'est qu'on

122
00:05:45,240 --> 00:05:47,430
voit qu'on a construit le
même tableau de 2 manières

123
00:05:47,630 --> 00:05:50,580
différentes: une première
version littérale et une

124
00:05:50,780 --> 00:05:52,860
deuxième version
dynamique ici, où j'ai vraiment

125
00:05:53,060 --> 00:05:57,730
instancier la classe (inaudible) à
la main et rempli chacune des cases.

126
00:05:59,590 --> 00:06:02,250
Donc on peut envoyer le
message "Size" à une collection

127
00:06:02,450 --> 00:06:05,240
pour récupérer sa taille. On
peut accéder à un élément d'une

128
00:06:05,440 --> 00:06:07,400
collection en lui
fournissant la méthode "At:".

129
00:06:07,800 --> 00:06:08,830
Donc ça je n'en ai déjà pas.

130
00:06:10,590 --> 00:06:12,610
Donc il faut faire
attention il y a une subtilité.

131
00:06:12,810 --> 00:06:14,760
Quand j'accède à un
élément d'une collection en

132
00:06:14,960 --> 00:06:17,190
fournissant un indice, il
faut faire attention que cet

133
00:06:17,390 --> 00:06:21,660
indice soit bien dans
les bornes acceptées par la

134
00:06:21,860 --> 00:06:23,700
collection, qu'il soit
inférieur à la taille de la collection.

135
00:06:24,030 --> 00:06:26,950
Si je demande à cette
collection l'élément à l'indice 55

136
00:06:27,150 --> 00:06:28,790
forcément il n'existe pas
puisque cette collection a une

137
00:06:29,000 --> 00:06:30,330
taille 3, donc ça va
bien me rendre une erreur.

138
00:06:33,500 --> 00:06:36,020
Donc pour modifier les
éléments, j'en ai parlé, à l'indice

139
00:06:36,220 --> 00:06:39,820
2 je veux modifier,
insérer un nouvel élément dans la

140
00:06:40,020 --> 00:06:41,310
collection, la chaine
des caractères (inaudible).

141
00:06:41,620 --> 00:06:44,530
Donc ça bien remplacer
(inaudible) par (inaudible), on le

142
00:06:44,730 --> 00:06:49,130
voit bien ici dans le

143
00:06:49,330 --> 00:06:50,090
résultat.

144
00:06:50,290 --> 00:06:54,590
Donc les tableaux littéraux,
donc on a ici un exemple de

145
00:06:54,790 --> 00:06:57,390
tableau littéral, ça
commence par Dièse parenthèse comme

146
00:06:57,590 --> 00:06:59,310
je vous l'avais dit, on peut
mettre n'importe quoi dedans

147
00:06:59,510 --> 00:07:01,540
donc un nom ou une chaine
de caractères et cetera.

148
00:07:02,280 --> 00:07:06,000
Et puis tous les tableaux
littéraux en Faro sont instance

149
00:07:06,200 --> 00:07:07,350
de la classe (inaudible) par défaut.

150
00:07:08,100 --> 00:07:10,470
Donc je peux envoyer le
message "Classe" à un tableau

151
00:07:10,670 --> 00:07:12,290
littéral et ça me
rend bien (inaudible).

152
00:07:12,490 --> 00:07:14,590
Donc c'est bien une
instance de la classe (inaudible).

153
00:07:18,850 --> 00:07:21,000
Alors les versions
dynamiques et les versions littérales

154
00:07:21,200 --> 00:07:22,760
sont exactement équivalentes en Faro.

155
00:07:22,960 --> 00:07:26,000
C'est juste une version plus concise,
donc ça permet d'écrire ça plus vite.

156
00:07:26,630 --> 00:07:30,020
Donc ici vous avez la
version littérale d'une collection

157
00:07:30,220 --> 00:07:32,510
et vous avez sa version
dynamique où j'instancie vraiment

158
00:07:32,710 --> 00:07:33,470
la classe (inaudible) à la main.

159
00:07:33,830 --> 00:07:35,440
Mais c'est complètement
équivalent puisque vous voyez

160
00:07:35,640 --> 00:07:36,830
bien que les 2
résultats sont les mêmes.

161
00:07:40,080 --> 00:07:42,670
Donc la classe
(inaudible) collection définit une

162
00:07:42,870 --> 00:07:46,000
collection particulière,
qui est extensible, donc à

163
00:07:46,200 --> 00:07:48,550
chaque fois qu'on va ajouter
des éléments elle va s'agrandir.

164
00:07:49,290 --> 00:07:52,360
Donc ici j'instancie la
création (inaudible) collection

165
00:07:52,560 --> 00:07:53,460
en envoyant un message New.

166
00:07:53,660 --> 00:07:55,670
J'utilise la méthode
"Ad" pour ajouter différents

167
00:07:55,870 --> 00:07:58,510
éléments dans cette
collection. J'ai même des variations

168
00:07:58,710 --> 00:08:00,870
je peux faire "Ad first"
pour ajouter un élément au début

169
00:08:01,070 --> 00:08:02,610
de la collection, par
défaut il s'ajoute à la fin.

170
00:08:04,510 --> 00:08:07,890
Donc vous voyez à chaque fois
ce que nous rend la collection.

171
00:08:08,090 --> 00:08:11,450
Donc là on a bien 3 éléments dans la
collection: Faro, (inaudible) et Faro.

172
00:08:11,720 --> 00:08:14,660
Si je fais "Ad see side",
"see side" est bien ajouté à la

173
00:08:14,860 --> 00:08:15,620
fin de la collection.

174
00:08:18,180 --> 00:08:21,300
J'ai des méthodes de conversion
entre un type de collection et un autre.

175
00:08:21,650 --> 00:08:24,840
Donc par exemple ici
j'utilise une collection littérale,

176
00:08:25,040 --> 00:08:27,380
donc qui va être
(inaudible) et le message (inaudible)

177
00:08:27,580 --> 00:08:32,280
collection qui va transformer ce
tableau en collection (inaudible.

178
00:08:33,750 --> 00:08:37,020
Enfin les 7. Donc les 7 sont un
type de collection sans doublon.

179
00:08:37,450 --> 00:08:39,670
Donc pareil de taille
extensible, donc à chaque fois que

180
00:08:39,870 --> 00:08:41,490
va ajouter un élément ça va grandir.

181
00:08:41,840 --> 00:08:44,800
Je peux utiliser une
collection littérale que je

182
00:08:45,000 --> 00:08:48,030
transforme en 7 et ça me
donne bien un 7 dans lequel les

183
00:08:48,230 --> 00:08:49,000
doublons ont été retirés.

184
00:08:50,440 --> 00:08:52,140
Ou alors je peux accéder à la
version dynamique plutôt qu'une

185
00:08:52,340 --> 00:08:56,220
collection littérale. 7
(inaudible) qui permet de créer

186
00:08:56,420 --> 00:08:59,090
un 7 et de le remplir avec 2
éléments, deux 7 à chaque fois.

187
00:09:02,210 --> 00:09:03,800
Donc les méthodes de
conversion sont extrêmement

188
00:09:04,000 --> 00:09:06,760
pratiques pour jongler, pour
transformer une collection en un autre type.

189
00:09:07,000 --> 00:09:09,880
Elles ont toujours la même
forme c'est "As" plus le nom

190
00:09:10,080 --> 00:09:11,250
de la collection qu'on voudra avoir.

191
00:09:14,080 --> 00:09:16,430
Les dictionnaires. Donc c'est un
type de collection clés,valeurs.

192
00:09:16,630 --> 00:09:19,020
À une clé donnée
j'associe une valeur.

193
00:09:19,390 --> 00:09:21,180
Elles sont aussi
extensibles à chaque fois qu'on va

194
00:09:21,380 --> 00:09:23,640
ajouter des éléments elles
vont grandir, et puis on a une

195
00:09:23,840 --> 00:09:28,400
API un peu
particulière sur cette collection,

196
00:09:28,690 --> 00:09:32,460
donc le message "At" qui lui est
 classique, (inaudible) c'est-à-dire

197
00:09:32,660 --> 00:09:34,440
si je veux accéder à un
élément, à une clé particulière

198
00:09:35,060 --> 00:09:37,890
mais qu'elle n'existe pas,
qu'est-ce que je dois rendre?

199
00:09:38,090 --> 00:09:40,840
"At put" donc à une clé
particulière je veux insérer une

200
00:09:41,040 --> 00:09:43,420
nouvelle valeur et cetera.
Et puis je vais pouvoir itérer

201
00:09:43,620 --> 00:09:47,160
avec des messages tout à
fait classiques "Do", on a déjà

202
00:09:47,360 --> 00:09:50,090
vu, mais on va avoir des
nouveaux messages "Keys Do" donc

203
00:09:50,290 --> 00:09:54,060
je parcours toutes les clés du
dictionnaire ou les clés et les valeurs.

204
00:09:54,520 --> 00:09:55,520
Donc je vous donne un exemple.

205
00:09:55,720 --> 00:09:59,060
Ici j'ai créé l'instance de
la classe dictionnaire, et

206
00:09:59,260 --> 00:10:02,110
puis dans ce
dictionnaire, donc il faut voir un

207
00:10:02,310 --> 00:10:05,590
dictionnaire un peu comme un
tableau, à la clé janvier j'associe

208
00:10:05,790 --> 00:10:09,820
le nombre 31, à la clé février le
nombre 28 et à la clé mars le nombre 31.

209
00:10:13,020 --> 00:10:16,320
Donc c'est complètement
équivalent à une collection dynamique.

210
00:10:16,520 --> 00:10:21,060
Donc une collection dynamique cette
fois c'est créé avec une accolade.

211
00:10:21,260 --> 00:10:22,860
Accolade ouvrante, accolade fermante.

212
00:10:23,840 --> 00:10:26,390
Ici je vous rappelle la flèche
c'est pour créer des associations.

213
00:10:27,060 --> 00:10:28,900
Donc ici j'ai un symbole.

214
00:10:29,290 --> 00:10:33,000
Donc au symbole janvier
j'associe le nombre 31, donc ici

215
00:10:33,700 --> 00:10:36,610
j'ai bien une collection
d'associations que je transforme

216
00:10:36,810 --> 00:10:38,150
en dictionnaire avec
à le "Ad dictionary".

217
00:10:38,620 --> 00:10:42,760
Donc ces 2 formes pour créer le
dictionnaire sont complètement équivalentes.

218
00:10:45,680 --> 00:10:47,830
Donc si je demande à une
association, si je lui demande

219
00:10:48,030 --> 00:10:50,640
sa clé ça va bien nous
renvoyer la clé, donc le début.

220
00:10:50,840 --> 00:10:52,380
On voit qu'ici c'est l'équivalent.

221
00:10:52,700 --> 00:10:54,640
Et puis si je demande à une
association de me retourner

222
00:10:54,840 --> 00:10:56,160
sa valeur ça ne me
retourne que la valeur.

223
00:10:56,510 --> 00:10:58,410
Donc ça c'est une
paire ou une association.

224
00:11:00,670 --> 00:11:01,620
Donc les dictionnaires.

225
00:11:02,000 --> 00:11:05,630
Si je veux dans un
dictionnaire accéder à une valeur

226
00:11:05,830 --> 00:11:09,420
particulière, il suffit que
j'utilise "At" et la clé, je

227
00:11:09,620 --> 00:11:11,240
spécifie la clé pour
laquelle je veux la valeur.

228
00:11:11,880 --> 00:11:15,250
Si c'est une clé qui est
inexistante forcément je vais

229
00:11:15,560 --> 00:11:16,660
récupérer une erreur en retour.

230
00:11:18,720 --> 00:11:21,310
Et si je veux éviter ça
ce que je peux faire c'est

231
00:11:21,510 --> 00:11:25,640
utiliser "At if absent", donc
je fais "At" une clé qui n'existe

232
00:11:25,840 --> 00:11:28,010
pas dans le dictionnaire, et
si c'est absent donc je vais

233
00:11:28,210 --> 00:11:30,590
récupérer la valeur qui est ici le 0.

234
00:11:31,760 --> 00:11:33,020
Donc on voit bien cette
clé n'existe pas dans le

235
00:11:33,220 --> 00:11:34,000
dictionnaire donc je
récupère la valeur 0.

236
00:11:35,320 --> 00:11:37,730
Je peux itérer sur un
dictionnaire, donc si je fais un

237
00:11:37,930 --> 00:11:41,400
"Do" sur les éléments d'un
dictionnaire je récupère en

238
00:11:41,600 --> 00:11:44,040
fait ici que les
valeurs du dictionnaire.

239
00:11:44,280 --> 00:11:45,040
On ne voit pas les clés.

240
00:11:45,460 --> 00:11:46,950
Alors pourquoi on
peut se demander ça?

241
00:11:47,150 --> 00:11:48,950
C'est un peu bizarre de ne
récupérer que les valeurs.

242
00:11:49,150 --> 00:11:51,740
En fait c'est complètement
logique puisque si on regarde

243
00:11:51,940 --> 00:11:53,460
dans la classe
"dictionnaire" l'implémentation de la

244
00:11:53,660 --> 00:11:57,170
méthode "Do", qui prend un bloc,
en fait elle fait à l'intérieur

245
00:11:57,370 --> 00:12:00,860
Self values do". Donc par
défaut quand en fait un "Do"

246
00:12:01,060 --> 00:12:03,570
sur un dictionnaire, on ne
parcourt que ses valeurs et pas les clés.

247
00:12:05,520 --> 00:12:08,060
Si je veux parcourir les
2 en fait j'ai une méthode

248
00:12:08,260 --> 00:12:11,000
particulière qui s'appelle
"Keys and values do", qui

249
00:12:11,200 --> 00:12:14,720
prend en paramètre un bloc
avec 2 arguments: K et V.

250
00:12:15,340 --> 00:12:18,510
Et donc K ça correspondra
bien à une clé et V à la valeur.

251
00:12:19,350 --> 00:12:22,000
Donc cette fois j'ai bien
mon dictionnaire complet.

252
00:12:24,000 --> 00:12:27,500
Donc en résumé dans cette
séquence on a vu que Faro

253
00:12:27,700 --> 00:12:30,170
propose énormément de types
de collections différents.

254
00:12:31,290 --> 00:12:33,300
Que toutes les
collections proposent un vocabulaire

255
00:12:33,500 --> 00:12:36,000
commun, que ce soit pour
créer des collections, pour

256
00:12:36,200 --> 00:12:38,610
accéder aux éléments, pour accéder à
la taille d'une collection et cetera.

257
00:12:39,000 --> 00:12:40,350
Donc ça ça facilite
la vie du programmeur.

258
00:12:41,290 --> 00:12:44,370
Et c'est simple aussi de convertir un
type de collection en un autre type.

259
00:12:44,950 --> 00:12:46,840
Et vous on a même vu quelque
chose de supplémentaire, on

260
00:12:47,040 --> 00:12:49,080
a vu que quand on se pose des
questions il est facile d'aller

261
00:12:49,280 --> 00:12:51,760
découvrir dans le système,
dans Faro, en allant lire le

262
00:12:52,000 --> 00:12:54,280
code des classes, en allant découvrir
de nouvelles classes de collections.

